# æŠ€æœ¯å‘˜è‡ªä¸»é€‰æ‹©è®¢å•ç³»ç»Ÿ - è¯¦ç»†æŠ€æœ¯æ–¹æ¡ˆ

**ä½œè€…ï¼š** MiniMax Agent  
**æ—¥æœŸï¼š** 2025-07-17

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### è®¾è®¡ç†å¿µ
ä»ä¼ ç»Ÿçš„"æ™ºèƒ½åˆ†é…"æ¨¡å¼è½¬å˜ä¸º"æŠ€æœ¯å‘˜è‡ªä¸»é€‰æ‹©"æ¨¡å¼ï¼Œè®©æŠ€æœ¯å‘˜æ ¹æ®è‡ªå·±çš„æŠ€èƒ½ä¸“é•¿ã€å·¥ä½œè´Ÿè½½å’Œä¸ªäººåå¥½ä¸»åŠ¨é€‰æ‹©è®¢å•ï¼Œä»è€Œæé«˜å·¥ä½œæ•ˆç‡å’Œæ»¡æ„åº¦ã€‚

### æ ¸å¿ƒä¼˜åŠ¿
- **æå‡å·¥ä½œç§¯ææ€§** - æŠ€æœ¯å‘˜å¯ä»¥é€‰æ‹©æ“…é•¿çš„ç»´ä¿®ç±»å‹
- **ä¼˜åŒ–æŠ€èƒ½åŒ¹é…** - å……åˆ†å‘æŒ¥ä¸ªäººä¸“ä¸šä¼˜åŠ¿
- **å‡å°‘åˆ†é…äº‰è®®** - é¿å…è¢«åŠ¨åˆ†é…å¸¦æ¥çš„ä¸æ»¡
- **æé«˜å¤„ç†æ•ˆç‡** - ä¸»åŠ¨é€‰æ‹©çš„è®¢å•å®Œæˆè´¨é‡æ›´é«˜

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1. è®¢å•æ± ç®¡ç†æ¶æ„

```mermaid
graph TB
    A[æ–°è®¢å•åˆ›å»º] --> B[è®¢å•æ± ]
    B --> C[è®¢å•å±•ç¤ºå±‚]
    C --> D[æŠ€æœ¯å‘˜é€‰æ‹©ç•Œé¢]
    D --> E[é€‰æ‹©æƒé™éªŒè¯]
    E --> F[è®¢å•åˆ†é…ç¡®è®¤]
    F --> G[å·¥ä½œè´Ÿè½½æ›´æ–°]
    G --> H[é€šçŸ¥ç³»ç»Ÿ]
```

### 2. æ•°æ®åº“è®¾è®¡

```sql
-- è®¢å•æ± çŠ¶æ€è¡¨
CREATE TABLE order_pool (
    id SERIAL PRIMARY KEY,
    order_id INTEGER UNIQUE REFERENCES orders(id),
    pool_status VARCHAR(20) DEFAULT 'available', -- available, selected, assigned, expired
    priority_level INTEGER DEFAULT 1, -- 1:ä½ 2:ä¸­ 3:é«˜ 4:ç´§æ€¥
    difficulty_level INTEGER DEFAULT 1, -- 1-5çº§éš¾åº¦
    estimated_duration INTEGER, -- é¢„ä¼°å®Œæˆæ—¶é—´(åˆ†é’Ÿ)
    required_skills JSON, -- æ‰€éœ€æŠ€èƒ½æ ‡ç­¾ ["screen_repair", "battery_replacement"]
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    expires_at TIMESTAMP, -- è®¢å•æ± è¿‡æœŸæ—¶é—´
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æŠ€æœ¯å‘˜é€‰æ‹©è®°å½•è¡¨
CREATE TABLE technician_selections (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    technician_id INTEGER REFERENCES users(id),
    selection_timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    selection_reason TEXT, -- é€‰æ‹©ç†ç”±
    estimated_completion_time INTEGER, -- æŠ€æœ¯å‘˜é¢„ä¼°å®Œæˆæ—¶é—´
    confidence_level INTEGER CHECK (confidence_level >= 1 AND confidence_level <= 5), -- ä¿¡å¿ƒç­‰çº§
    status VARCHAR(20) DEFAULT 'pending', -- pending, confirmed, cancelled
    confirmed_at TIMESTAMP,
    cancelled_at TIMESTAMP,
    cancellation_reason TEXT
);

-- æŠ€æœ¯å‘˜æŠ€èƒ½çŸ©é˜µè¡¨
CREATE TABLE technician_skills (
    id SERIAL PRIMARY KEY,
    technician_id INTEGER REFERENCES users(id),
    skill_name VARCHAR(100) NOT NULL,
    skill_level INTEGER CHECK (skill_level >= 1 AND skill_level <= 5), -- 1:åˆçº§ 5:ä¸“å®¶
    experience_count INTEGER DEFAULT 0, -- å¤„ç†è¿‡çš„ç›¸å…³è®¢å•æ•°é‡
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    is_certified BOOLEAN DEFAULT FALSE, -- æ˜¯å¦æœ‰ç›¸å…³è®¤è¯
    UNIQUE(technician_id, skill_name)
);

-- æŠ€æœ¯å‘˜å·¥ä½œè´Ÿè½½è¡¨
CREATE TABLE technician_workload (
    id SERIAL PRIMARY KEY,
    technician_id INTEGER UNIQUE REFERENCES users(id),
    current_orders_count INTEGER DEFAULT 0,
    max_concurrent_orders INTEGER DEFAULT 3, -- æœ€å¤§å¹¶å‘è®¢å•æ•°
    total_estimated_hours DECIMAL(5,2) DEFAULT 0, -- å½“å‰æ€»é¢„ä¼°å·¥æ—¶
    availability_status VARCHAR(20) DEFAULT 'available', -- available, busy, unavailable
    last_selection_time TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- è®¢å•é€‰æ‹©åå¥½è¡¨
CREATE TABLE selection_preferences (
    id SERIAL PRIMARY KEY,
    technician_id INTEGER REFERENCES users(id),
    preferred_device_brands JSON, -- ["Apple", "Samsung", "Huawei"]
    preferred_repair_types JSON, -- ["screen", "battery", "camera"]
    preferred_difficulty_range JSON, -- {"min": 1, "max": 4}
    preferred_duration_range JSON, -- {"min": 30, "max": 180} åˆ†é’Ÿ
    avoid_urgent_orders BOOLEAN DEFAULT FALSE,
    auto_select_enabled BOOLEAN DEFAULT FALSE, -- æ˜¯å¦å¯ç”¨è‡ªåŠ¨é€‰æ‹©
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

### 3. æ ¸å¿ƒæœåŠ¡ç±»è®¾è®¡

```typescript
// è®¢å•æ± ç®¡ç†æœåŠ¡
export class OrderPoolService {
  // æ·»åŠ è®¢å•åˆ°æ± ä¸­
  async addOrderToPool(orderId: number, priority: number = 1): Promise<void> {
    const order = await this.getOrderDetails(orderId);
    
    const poolEntry = {
      order_id: orderId,
      pool_status: 'available',
      priority_level: priority,
      difficulty_level: await this.calculateDifficultyLevel(order),
      estimated_duration: await this.estimateDuration(order),
      required_skills: await this.extractRequiredSkills(order),
      expires_at: new Date(Date.now() + 24 * 60 * 60 * 1000) // 24å°æ—¶åè¿‡æœŸ
    };

    await prisma.orderPool.create({ data: poolEntry });
    
    // é€šçŸ¥ç¬¦åˆæ¡ä»¶çš„æŠ€æœ¯å‘˜
    await this.notifyEligibleTechnicians(poolEntry);
  }

  // è·å–å¯ç”¨è®¢å•åˆ—è¡¨
  async getAvailableOrders(technicianId: number): Promise<OrderPoolEntry[]> {
    const technician = await this.getTechnicianProfile(technicianId);
    
    return await prisma.orderPool.findMany({
      where: {
        pool_status: 'available',
        expires_at: { gt: new Date() },
        // æ ¹æ®æŠ€æœ¯å‘˜æŠ€èƒ½è¿‡æ»¤
        required_skills: {
          array_contains: technician.skills
        }
      },
      include: {
        order: {
          include: {
            customer: true,
            device: true
          }
        }
      },
      orderBy: [
        { priority_level: 'desc' },
        { created_at: 'asc' }
      ]
    });
  }

  // æŠ€æœ¯å‘˜é€‰æ‹©è®¢å•
  async selectOrder(
    orderId: number, 
    technicianId: number, 
    selectionData: SelectionRequest
  ): Promise<SelectionResult> {
    // 1. éªŒè¯è®¢å•å¯ç”¨æ€§
    const orderPool = await prisma.orderPool.findFirst({
      where: {
        order_id: orderId,
        pool_status: 'available'
      }
    });

    if (!orderPool) {
      throw new Error('è®¢å•ä¸å¯ç”¨æˆ–å·²è¢«é€‰æ‹©');
    }

    // 2. æ£€æŸ¥æŠ€æœ¯å‘˜å·¥ä½œè´Ÿè½½
    const workload = await this.checkTechnicianWorkload(technicianId);
    if (!workload.canTakeMore) {
      throw new Error('å½“å‰å·¥ä½œè´Ÿè½½å·²æ»¡ï¼Œæ— æ³•æ¥å—æ–°è®¢å•');
    }

    // 3. éªŒè¯æŠ€èƒ½åŒ¹é…
    const skillMatch = await this.validateSkillMatch(orderId, technicianId);
    if (!skillMatch.isEligible) {
      throw new Error(`æŠ€èƒ½ä¸åŒ¹é…: ${skillMatch.missingSkills.join(', ')}`);
    }

    // 4. åˆ›å»ºé€‰æ‹©è®°å½•
    const selection = await prisma.technicianSelection.create({
      data: {
        order_id: orderId,
        technician_id: technicianId,
        selection_reason: selectionData.reason,
        estimated_completion_time: selectionData.estimatedTime,
        confidence_level: selectionData.confidenceLevel,
        status: 'pending'
      }
    });

    // 5. æ›´æ–°è®¢å•æ± çŠ¶æ€
    await prisma.orderPool.update({
      where: { order_id: orderId },
      data: { pool_status: 'selected' }
    });

    // 6. æ›´æ–°æŠ€æœ¯å‘˜å·¥ä½œè´Ÿè½½
    await this.updateTechnicianWorkload(technicianId, orderId);

    // 7. å‘é€ç¡®è®¤é€šçŸ¥
    await this.sendSelectionConfirmation(selection);

    return {
      success: true,
      selectionId: selection.id,
      message: 'è®¢å•é€‰æ‹©æˆåŠŸï¼Œç­‰å¾…ç®¡ç†å‘˜ç¡®è®¤'
    };
  }

  // è®¡ç®—è®¢å•éš¾åº¦ç­‰çº§
  private async calculateDifficultyLevel(order: Order): Promise<number> {
    const factors = {
      deviceAge: this.getDeviceAgeFactor(order.device),
      repairComplexity: this.getRepairComplexityFactor(order.issue_description),
      partAvailability: await this.getPartAvailabilityFactor(order.device_model),
      customerHistory: await this.getCustomerComplexityFactor(order.customer_id)
    };

    // ç»¼åˆè®¡ç®—éš¾åº¦ç­‰çº§ (1-5)
    const avgFactor = Object.values(factors).reduce((a, b) => a + b, 0) / 4;
    return Math.ceil(avgFactor);
  }

  // æå–æ‰€éœ€æŠ€èƒ½
  private async extractRequiredSkills(order: Order): Promise<string[]> {
    const skills = [];
    
    // åŸºäºè®¾å¤‡å‹å·çš„æŠ€èƒ½
    if (order.device_model.includes('iPhone')) {
      skills.push('ios_repair');
    } else if (order.device_model.includes('Samsung')) {
      skills.push('android_repair');
    }

    // åŸºäºæ•…éšœæè¿°çš„æŠ€èƒ½
    const issueKeywords = {
      'screen': ['screen_repair', 'display_replacement'],
      'battery': ['battery_replacement', 'power_management'],
      'camera': ['camera_repair', 'optical_systems'],
      'water': ['water_damage_repair', 'board_level_repair'],
      'charging': ['charging_port_repair', 'power_circuits']
    };

    const description = order.issue_description.toLowerCase();
    for (const [keyword, relatedSkills] of Object.entries(issueKeywords)) {
      if (description.includes(keyword)) {
        skills.push(...relatedSkills);
      }
    }

    return [...new Set(skills)]; // å»é‡
  }
}
```

### 4. å‰ç«¯ç•Œé¢è®¾è®¡

#### æŠ€æœ¯å‘˜è®¢å•æ± ç•Œé¢
```typescript
// è®¢å•æ± ä¸»ç•Œé¢ç»„ä»¶
export default function OrderPoolDashboard() {
  const [availableOrders, setAvailableOrders] = useState<OrderPoolEntry[]>([]);
  const [selectedOrders, setSelectedOrders] = useState<OrderPoolEntry[]>([]);
  const [filters, setFilters] = useState<OrderFilters>({
    difficulty: [1, 5],
    priority: 'all',
    deviceBrand: 'all',
    estimatedDuration: [0, 480]
  });
  const [workloadStatus, setWorkloadStatus] = useState<WorkloadStatus>(null);

  useEffect(() => {
    loadAvailableOrders();
    loadWorkloadStatus();
    
    // æ¯30ç§’åˆ·æ–°ä¸€æ¬¡
    const interval = setInterval(loadAvailableOrders, 30000);
    return () => clearInterval(interval);
  }, [filters]);

  const loadAvailableOrders = async () => {
    try {
      const orders = await api.get('/api/order-pool/available', { 
        params: filters 
      });
      setAvailableOrders(orders.data);
    } catch (error) {
      console.error('åŠ è½½è®¢å•å¤±è´¥:', error);
    }
  };

  const handleOrderSelection = async (orderId: number) => {
    const selectionModal = (
      <OrderSelectionModal
        orderId={orderId}
        onConfirm={async (selectionData) => {
          try {
            await api.post('/api/order-pool/select', {
              orderId,
              ...selectionData
            });
            
            toast.success('è®¢å•é€‰æ‹©æˆåŠŸï¼');
            await loadAvailableOrders();
            await loadWorkloadStatus();
          } catch (error) {
            toast.error(error.response?.data?.message || 'é€‰æ‹©å¤±è´¥');
          }
        }}
        onCancel={() => setShowModal(false)}
      />
    );
    
    setShowModal(selectionModal);
  };

  return (
    <div className="order-pool-dashboard">
      {/* å·¥ä½œè´Ÿè½½çŠ¶æ€æ  */}
      <WorkloadStatusBar status={workloadStatus} />
      
      {/* è¿‡æ»¤å™¨æ§ä»¶ */}
      <OrderFilters 
        filters={filters} 
        onChange={setFilters}
        availableSkills={userSkills}
      />
      
      {/* è®¢å•åˆ—è¡¨ */}
      <div className="order-grid">
        {availableOrders.map(order => (
          <OrderCard
            key={order.id}
            order={order}
            onSelect={() => handleOrderSelection(order.order_id)}
            skillMatch={calculateSkillMatch(order.required_skills, userSkills)}
          />
        ))}
      </div>
      
      {/* å·²é€‰æ‹©è®¢å•é¢æ¿ */}
      <SelectedOrdersPanel orders={selectedOrders} />
    </div>
  );
}

// è®¢å•å¡ç‰‡ç»„ä»¶
function OrderCard({ order, onSelect, skillMatch }) {
  const priorityColors = {
    1: 'bg-gray-100',
    2: 'bg-blue-100', 
    3: 'bg-yellow-100',
    4: 'bg-red-100'
  };

  const difficultyStars = 'â˜…'.repeat(order.difficulty_level) + 
                         'â˜†'.repeat(5 - order.difficulty_level);

  return (
    <div className={`order-card ${priorityColors[order.priority_level]}`}>
      <div className="order-header">
        <span className="order-number">#{order.order.order_number}</span>
        <span className="priority-badge">
          {['', 'æ™®é€š', 'ä¸­ç­‰', 'ä¼˜å…ˆ', 'ç´§æ€¥'][order.priority_level]}
        </span>
      </div>
      
      <div className="order-details">
        <h3>{order.order.device.brand} {order.order.device.model}</h3>
        <p className="issue">{order.order.issue_description}</p>
        
        <div className="order-meta">
          <div className="difficulty">
            éš¾åº¦: <span className="stars">{difficultyStars}</span>
          </div>
          <div className="duration">
            é¢„ä¼°: {order.estimated_duration}åˆ†é’Ÿ
          </div>
          <div className="customer">
            å®¢æˆ·: {order.order.customer.name}
          </div>
        </div>
        
        <div className="skills-match">
          <h4>æŠ€èƒ½åŒ¹é…åº¦: {skillMatch.percentage}%</h4>
          <div className="required-skills">
            {order.required_skills.map(skill => (
              <span 
                key={skill}
                className={`skill-tag ${skillMatch.matched.includes(skill) ? 'matched' : 'missing'}`}
              >
                {skill}
              </span>
            ))}
          </div>
        </div>
      </div>
      
      <div className="order-actions">
        <button 
          className="select-btn"
          onClick={onSelect}
          disabled={skillMatch.percentage < 70}
        >
          é€‰æ‹©æ­¤è®¢å•
        </button>
        <button className="details-btn">
          æŸ¥çœ‹è¯¦æƒ…
        </button>
      </div>
      
      <div className="order-footer">
        <span className="created-time">
          {formatDistanceToNow(new Date(order.created_at))}å‰
        </span>
        <span className="expires-time">
          {formatDistanceToNow(new Date(order.expires_at))}åè¿‡æœŸ
        </span>
      </div>
    </div>
  );
}

// è®¢å•é€‰æ‹©ç¡®è®¤æ¨¡æ€æ¡†
function OrderSelectionModal({ orderId, onConfirm, onCancel }) {
  const [selectionData, setSelectionData] = useState({
    reason: '',
    estimatedTime: 60,
    confidenceLevel: 3
  });
  const [orderDetails, setOrderDetails] = useState(null);

  useEffect(() => {
    loadOrderDetails();
  }, [orderId]);

  const loadOrderDetails = async () => {
    const details = await api.get(`/api/orders/${orderId}/details`);
    setOrderDetails(details.data);
  };

  return (
    <Modal isOpen onRequestClose={onCancel}>
      <div className="selection-modal">
        <h2>ç¡®è®¤é€‰æ‹©è®¢å•</h2>
        
        {orderDetails && (
          <div className="order-summary">
            <h3>è®¢å•ä¿¡æ¯</h3>
            <p><strong>è®¾å¤‡:</strong> {orderDetails.device_model}</p>
            <p><strong>é—®é¢˜:</strong> {orderDetails.issue_description}</p>
            <p><strong>å®¢æˆ·:</strong> {orderDetails.customer.name}</p>
          </div>
        )}
        
        <div className="selection-form">
          <div className="form-group">
            <label>é€‰æ‹©ç†ç”±:</label>
            <textarea
              value={selectionData.reason}
              onChange={(e) => setSelectionData({
                ...selectionData,
                reason: e.target.value
              })}
              placeholder="ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªè®¢å•ï¼Ÿï¼ˆå¯é€‰ï¼‰"
              rows={3}
            />
          </div>
          
          <div className="form-group">
            <label>é¢„ä¼°å®Œæˆæ—¶é—´ï¼ˆåˆ†é’Ÿï¼‰:</label>
            <input
              type="number"
              value={selectionData.estimatedTime}
              onChange={(e) => setSelectionData({
                ...selectionData,
                estimatedTime: parseInt(e.target.value)
              })}
              min={15}
              max={480}
            />
          </div>
          
          <div className="form-group">
            <label>ä¿¡å¿ƒç­‰çº§:</label>
            <select
              value={selectionData.confidenceLevel}
              onChange={(e) => setSelectionData({
                ...selectionData,
                confidenceLevel: parseInt(e.target.value)
              })}
            >
              <option value={1}>1 - éœ€è¦æ”¯æŒ</option>
              <option value={2}>2 - æœ‰äº›ä¸ç¡®å®š</option>
              <option value={3}>3 - æœ‰ä¿¡å¿ƒ</option>
              <option value={4}>4 - å¾ˆæœ‰ä¿¡å¿ƒ</option>
              <option value={5}>5 - å®Œå…¨ç¡®å®š</option>
            </select>
          </div>
        </div>
        
        <div className="modal-actions">
          <button 
            className="confirm-btn"
            onClick={() => onConfirm(selectionData)}
            disabled={!selectionData.estimatedTime}
          >
            ç¡®è®¤é€‰æ‹©
          </button>
          <button className="cancel-btn" onClick={onCancel}>
            å–æ¶ˆ
          </button>
        </div>
      </div>
    </Modal>
  );
}
```

## ğŸ”§ é«˜çº§åŠŸèƒ½å®ç°

### 1. æ™ºèƒ½æ¨èç®—æ³•

```typescript
// è®¢å•æ¨èæœåŠ¡
export class OrderRecommendationService {
  // ä¸ºæŠ€æœ¯å‘˜æ¨èæœ€é€‚åˆçš„è®¢å•
  async getRecommendedOrders(technicianId: number): Promise<RecommendedOrder[]> {
    const technician = await this.getTechnicianProfile(technicianId);
    const availableOrders = await this.getAvailableOrders();
    
    const recommendations = await Promise.all(
      availableOrders.map(async order => {
        const score = await this.calculateRecommendationScore(order, technician);
        return {
          order,
          score,
          reasons: await this.getRecommendationReasons(order, technician, score)
        };
      })
    );

    return recommendations
      .filter(rec => rec.score > 0.6) // åªæ¨èè¯„åˆ†å¤§äº0.6çš„è®¢å•
      .sort((a, b) => b.score - a.score)
      .slice(0, 10); // æœ€å¤šæ¨è10ä¸ª
  }

  // è®¡ç®—æ¨èè¯„åˆ†
  private async calculateRecommendationScore(
    order: OrderPoolEntry, 
    technician: TechnicianProfile
  ): Promise<number> {
    const factors = {
      skillMatch: this.calculateSkillMatchScore(order.required_skills, technician.skills),
      experienceMatch: this.calculateExperienceScore(order, technician.experience),
      workloadBalance: this.calculateWorkloadScore(technician.currentWorkload),
      preferenceMatch: this.calculatePreferenceScore(order, technician.preferences),
      difficultyMatch: this.calculateDifficultyScore(order.difficulty_level, technician.skillLevel),
      urgencyFactor: this.calculateUrgencyFactor(order.priority_level),
      historicalSuccess: await this.getHistoricalSuccessRate(technician.id, order.required_skills)
    };

    // åŠ æƒè®¡ç®—æ€»åˆ†
    const weights = {
      skillMatch: 0.25,
      experienceMatch: 0.20,
      workloadBalance: 0.15,
      preferenceMatch: 0.15,
      difficultyMatch: 0.10,
      urgencyFactor: 0.10,
      historicalSuccess: 0.05
    };

    return Object.entries(factors).reduce((total, [factor, score]) => {
      return total + (score * weights[factor]);
    }, 0);
  }

  // ç”Ÿæˆæ¨èç†ç”±
  private async getRecommendationReasons(
    order: OrderPoolEntry,
    technician: TechnicianProfile,
    score: number
  ): Promise<string[]> {
    const reasons = [];

    if (score > 0.8) {
      reasons.push('ğŸ¯ éå¸¸é€‚åˆæ‚¨çš„æŠ€èƒ½ä¸“é•¿');
    }
    
    if (this.isPreferredDeviceBrand(order, technician.preferences)) {
      reasons.push('ğŸ“± æ‚¨åå¥½çš„è®¾å¤‡å“ç‰Œ');
    }
    
    if (order.difficulty_level <= technician.comfortableDifficultyLevel) {
      reasons.push('âš¡ éš¾åº¦é€‚ä¸­ï¼Œå¯å¿«é€Ÿå®Œæˆ');
    }
    
    if (order.priority_level >= 3) {
      reasons.push('ğŸš¨ é«˜ä¼˜å…ˆçº§è®¢å•ï¼Œå½±å“KPI');
    }
    
    const historicalRate = await this.getHistoricalSuccessRate(
      technician.id, 
      order.required_skills
    );
    if (historicalRate > 0.9) {
      reasons.push('âœ… æ‚¨åœ¨æ­¤ç±»ç»´ä¿®ä¸ŠæˆåŠŸç‡å¾ˆé«˜');
    }

    return reasons;
  }
}
```

### 2. è‡ªåŠ¨é€‰æ‹©åŠŸèƒ½

```typescript
// è‡ªåŠ¨é€‰æ‹©æœåŠ¡
export class AutoSelectionService {
  // ä¸ºå¯ç”¨è‡ªåŠ¨é€‰æ‹©çš„æŠ€æœ¯å‘˜è‡ªåŠ¨é€‰æ‹©è®¢å•
  async runAutoSelection(): Promise<void> {
    const autoSelectTechnicians = await this.getAutoSelectEnabledTechnicians();
    
    for (const technician of autoSelectTechnicians) {
      try {
        await this.processAutoSelectionForTechnician(technician.id);
      } catch (error) {
        console.error(`æŠ€æœ¯å‘˜ ${technician.id} è‡ªåŠ¨é€‰æ‹©å¤±è´¥:`, error);
      }
    }
  }

  private async processAutoSelectionForTechnician(technicianId: number): Promise<void> {
    // æ£€æŸ¥å·¥ä½œè´Ÿè½½
    const workload = await this.checkTechnicianWorkload(technicianId);
    if (!workload.canTakeMore) {
      return; // å·¥ä½œè´Ÿè½½å·²æ»¡
    }

    // è·å–æ¨èè®¢å•
    const recommendations = await this.orderRecommendationService
      .getRecommendedOrders(technicianId);
    
    if (recommendations.length === 0) {
      return; // æ²¡æœ‰åˆé€‚çš„è®¢å•
    }

    // é€‰æ‹©è¯„åˆ†æœ€é«˜çš„è®¢å•
    const bestRecommendation = recommendations[0];
    
    // æ£€æŸ¥æ˜¯å¦æ»¡è¶³è‡ªåŠ¨é€‰æ‹©æ¡ä»¶
    if (bestRecommendation.score >= 0.85) {
      await this.orderPoolService.selectOrder(
        bestRecommendation.order.order_id,
        technicianId,
        {
          reason: 'è‡ªåŠ¨é€‰æ‹© - ' + bestRecommendation.reasons.join(', '),
          estimatedTime: bestRecommendation.order.estimated_duration,
          confidenceLevel: Math.ceil(bestRecommendation.score * 5)
        }
      );

      // å‘é€é€šçŸ¥
      await this.notificationService.sendAutoSelectionNotification(
        technicianId,
        bestRecommendation.order
      );
    }
  }

  // è®¾ç½®è‡ªåŠ¨é€‰æ‹©åå¥½
  async updateAutoSelectionPreferences(
    technicianId: number,
    preferences: AutoSelectionPreferences
  ): Promise<void> {
    await prisma.selectionPreference.upsert({
      where: { technician_id: technicianId },
      update: {
        auto_select_enabled: preferences.enabled,
        preferred_device_brands: preferences.deviceBrands,
        preferred_repair_types: preferences.repairTypes,
        preferred_difficulty_range: preferences.difficultyRange,
        preferred_duration_range: preferences.durationRange,
        avoid_urgent_orders: preferences.avoidUrgent,
        min_confidence_score: preferences.minConfidenceScore,
        updated_at: new Date()
      },
      create: {
        technician_id: technicianId,
        auto_select_enabled: preferences.enabled,
        preferred_device_brands: preferences.deviceBrands,
        preferred_repair_types: preferences.repairTypes,
        preferred_difficulty_range: preferences.difficultyRange,
        preferred_duration_range: preferences.durationRange,
        avoid_urgent_orders: preferences.avoidUrgent,
        min_confidence_score: preferences.minConfidenceScore
      }
    });
  }
}
```

### 3. æ€§èƒ½ç›‘æ§å’Œåˆ†æ

```typescript
// é€‰æ‹©æ•ˆæœåˆ†ææœåŠ¡
export class SelectionAnalyticsService {
  // åˆ†ææŠ€æœ¯å‘˜é€‰æ‹©åå¥½
  async analyzeTechnicianSelectionPatterns(technicianId: number): Promise<SelectionAnalysis> {
    const selections = await prisma.technicianSelection.findMany({
      where: { 
        technician_id: technicianId,
        status: 'confirmed'
      },
      include: {
        order: {
          include: { order_pool: true }
        }
      },
      orderBy: { selection_timestamp: 'desc' },
      take: 100 // åˆ†ææœ€è¿‘100æ¬¡é€‰æ‹©
    });

    return {
      totalSelections: selections.length,
      averageConfidenceLevel: this.calculateAverageConfidence(selections),
      preferredDifficulty: this.analyzePreferredDifficulty(selections),
      preferredDeviceBrands: this.analyzePreferredBrands(selections),
      selectionSpeed: this.analyzeSelectionSpeed(selections),
      successRate: await this.calculateSelectionSuccessRate(technicianId),
      timePatterns: this.analyzeTimePatterns(selections)
    };
  }

  // ç³»ç»Ÿæ•´ä½“æ•ˆæœåˆ†æ
  async getSystemPerformanceMetrics(timeRange: string): Promise<SystemMetrics> {
    const startDate = this.getTimeRangeStart(timeRange);
    
    const metrics = await prisma.$queryRaw`
      SELECT 
        COUNT(*) as total_orders,
        COUNT(CASE WHEN pool_status = 'selected' THEN 1 END) as selected_orders,
        AVG(EXTRACT(EPOCH FROM (ts.selection_timestamp - op.created_at))/60) as avg_selection_time_minutes,
        AVG(ts.confidence_level) as avg_confidence,
        COUNT(CASE WHEN ts.status = 'confirmed' THEN 1 END) as confirmed_selections,
        COUNT(CASE WHEN ts.status = 'cancelled' THEN 1 END) as cancelled_selections
      FROM order_pool op
      LEFT JOIN technician_selections ts ON op.order_id = ts.order_id
      WHERE op.created_at >= ${startDate}
    `;

    return {
      orderPoolUtilization: (metrics[0].selected_orders / metrics[0].total_orders) * 100,
      averageSelectionTime: metrics[0].avg_selection_time_minutes,
      averageConfidence: metrics[0].avg_confidence,
      selectionConfirmationRate: (metrics[0].confirmed_selections / metrics[0].selected_orders) * 100,
      selectionCancellationRate: (metrics[0].cancelled_selections / metrics[0].selected_orders) * 100,
      technicianSatisfaction: await this.calculateTechnicianSatisfaction(timeRange),
      efficiencyImprovement: await this.calculateEfficiencyImprovement(timeRange)
    };
  }

  // ç”Ÿæˆä¼˜åŒ–å»ºè®®
  async generateOptimizationSuggestions(): Promise<OptimizationSuggestion[]> {
    const suggestions = [];
    
    // åˆ†æè®¢å•æ± æ»ç•™æƒ…å†µ
    const staleOrders = await this.getStaleOrders();
    if (staleOrders.length > 0) {
      suggestions.push({
        type: 'order_pool_optimization',
        priority: 'high',
        title: 'è®¢å•æ± æ»ç•™ä¼˜åŒ–',
        description: `å‘ç° ${staleOrders.length} ä¸ªè®¢å•è¶…è¿‡4å°æ—¶æœªè¢«é€‰æ‹©`,
        actions: [
          'é™ä½è¿™äº›è®¢å•çš„éš¾åº¦ç­‰çº§',
          'å¢åŠ æŠ€èƒ½åŒ¹é…èŒƒå›´',
          'æä¾›é¢å¤–æ¿€åŠ±æªæ–½'
        ]
      });
    }

    // åˆ†ææŠ€èƒ½ç¼ºå£
    const skillGaps = await this.analyzeSkillGaps();
    if (skillGaps.length > 0) {
      suggestions.push({
        type: 'skill_development',
        priority: 'medium',
        title: 'æŠ€èƒ½åŸ¹è®­å»ºè®®',
        description: `æ£€æµ‹åˆ°ä»¥ä¸‹æŠ€èƒ½éœ€æ±‚é‡å¤§ä½†ä¾›ç»™ä¸è¶³`,
        actions: skillGaps.map(skill => `åŠ å¼º ${skill} ç›¸å…³åŸ¹è®­`)
      });
    }

    return suggestions;
  }
}
```

## ğŸ“± ç§»åŠ¨ç«¯ä¼˜åŒ–

### 1. å“åº”å¼è®¾è®¡

```css
/* ç§»åŠ¨ç«¯è®¢å•æ± æ ·å¼ */
@media (max-width: 768px) {
  .order-pool-dashboard {
    padding: 1rem;
  }

  .order-grid {
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }

  .order-card {
    border-radius: 12px;
    padding: 1rem;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  }

  .order-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 0.5rem;
  }

  .order-details {
    margin-bottom: 1rem;
  }

  .skills-match {
    margin: 0.5rem 0;
  }

  .skill-tag {
    display: inline-block;
    padding: 0.25rem 0.5rem;
    margin: 0.125rem;
    border-radius: 20px;
    font-size: 0.75rem;
    font-weight: 500;
  }

  .skill-tag.matched {
    background-color: #10b981;
    color: white;
  }

  .skill-tag.missing {
    background-color: #ef4444;
    color: white;
  }

  .order-actions {
    display: flex;
    gap: 0.5rem;
  }

  .select-btn {
    flex: 1;
    padding: 0.75rem;
    background-color: #3b82f6;
    color: white;
    border: none;
    border-radius: 8px;
    font-weight: 600;
  }

  .select-btn:disabled {
    background-color: #9ca3af;
    cursor: not-allowed;
  }

  .details-btn {
    padding: 0.75rem 1rem;
    background-color: #f3f4f6;
    color: #374151;
    border: 1px solid #d1d5db;
    border-radius: 8px;
  }
}
```

### 2. ç¦»çº¿æ”¯æŒ

```typescript
// Service Worker for offline functionality
export class OrderPoolOfflineService {
  private readonly CACHE_NAME = 'order-pool-v1';
  private readonly OFFLINE_ORDERS_KEY = 'offline_orders';

  // ç¼“å­˜å¯ç”¨è®¢å•æ•°æ®
  async cacheOrderData(orders: OrderPoolEntry[]): Promise<void> {
    const cache = await caches.open(this.CACHE_NAME);
    
    // ç¼“å­˜è®¢å•åˆ—è¡¨
    await cache.put('/api/order-pool/available', new Response(JSON.stringify(orders)));
    
    // å°†è®¢å•å­˜å‚¨åˆ° localStorage ä½œä¸ºå¤‡ä»½
    localStorage.setItem(this.OFFLINE_ORDERS_KEY, JSON.stringify({
      timestamp: Date.now(),
      orders: orders
    }));
  }

  // ç¦»çº¿æ—¶è·å–ç¼“å­˜çš„è®¢å•
  async getOfflineOrders(): Promise<OrderPoolEntry[]> {
    try {
      // é¦–å…ˆå°è¯•ä» Service Worker ç¼“å­˜è·å–
      const cache = await caches.open(this.CACHE_NAME);
      const response = await cache.match('/api/order-pool/available');
      
      if (response) {
        return await response.json();
      }

      // fallbackåˆ°localStorage
      const offlineData = localStorage.getItem(this.OFFLINE_ORDERS_KEY);
      if (offlineData) {
        const parsed = JSON.parse(offlineData);
        // æ£€æŸ¥æ•°æ®æ˜¯å¦è¿‡æœŸï¼ˆè¶…è¿‡30åˆ†é’Ÿï¼‰
        if (Date.now() - parsed.timestamp < 30 * 60 * 1000) {
          return parsed.orders;
        }
      }

      return [];
    } catch (error) {
      console.error('è·å–ç¦»çº¿è®¢å•å¤±è´¥:', error);
      return [];
    }
  }

  // ç¦»çº¿é€‰æ‹©è®¢å•ï¼ˆå­˜å‚¨åˆ°é˜Ÿåˆ—ï¼‰
  async selectOrderOffline(
    orderId: number, 
    selectionData: SelectionRequest
  ): Promise<void> {
    const offlineQueue = this.getOfflineSelectionQueue();
    
    offlineQueue.push({
      orderId,
      selectionData,
      timestamp: Date.now(),
      id: crypto.randomUUID()
    });

    localStorage.setItem('offline_selection_queue', JSON.stringify(offlineQueue));
  }

  // ä¸Šçº¿ååŒæ­¥ç¦»çº¿æ“ä½œ
  async syncOfflineSelections(): Promise<void> {
    const queue = this.getOfflineSelectionQueue();
    
    for (const item of queue) {
      try {
        await api.post('/api/order-pool/select', {
          orderId: item.orderId,
          ...item.selectionData
        });
        
        // æˆåŠŸåä»é˜Ÿåˆ—ç§»é™¤
        this.removeFromOfflineQueue(item.id);
      } catch (error) {
        console.error(`åŒæ­¥ç¦»çº¿é€‰æ‹©å¤±è´¥ (è®¢å• ${item.orderId}):`, error);
      }
    }
  }

  private getOfflineSelectionQueue(): OfflineSelection[] {
    const queue = localStorage.getItem('offline_selection_queue');
    return queue ? JSON.parse(queue) : [];
  }

  private removeFromOfflineQueue(id: string): void {
    const queue = this.getOfflineSelectionQueue();
    const filtered = queue.filter(item => item.id !== id);
    localStorage.setItem('offline_selection_queue', JSON.stringify(filtered));
  }
}
```

## ğŸ”§ APIæ¥å£è®¾è®¡

### 1. RESTful APIè§„èŒƒ

```typescript
// APIè·¯ç”±å®šä¹‰
export const OrderPoolAPI = {
  // è·å–å¯ç”¨è®¢å•åˆ—è¡¨
  'GET /api/order-pool/available': {
    query: {
      difficulty?: number[], // [1,3] éš¾åº¦èŒƒå›´
      priority?: string,     // 'urgent', 'high', 'normal', 'low'
      skills?: string[],     // æŠ€èƒ½è¿‡æ»¤
      duration?: number[],   // [30,120] æ—¶é•¿èŒƒå›´
      deviceBrand?: string,  // è®¾å¤‡å“ç‰Œ
      page?: number,
      limit?: number
    },
    response: {
      orders: OrderPoolEntry[],
      total: number,
      hasMore: boolean
    }
  },

  // é€‰æ‹©è®¢å•
  'POST /api/order-pool/select': {
    body: {
      orderId: number,
      reason?: string,
      estimatedTime: number,
      confidenceLevel: number // 1-5
    },
    response: {
      success: boolean,
      selectionId: number,
      message: string
    }
  },

  // å–æ¶ˆé€‰æ‹©
  'DELETE /api/order-pool/select/:selectionId': {
    body: {
      cancellationReason: string
    },
    response: {
      success: boolean,
      message: string
    }
  },

  // è·å–æŠ€æœ¯å‘˜å·¥ä½œè´Ÿè½½
  'GET /api/technician/workload': {
    response: {
      currentOrders: number,
      maxConcurrent: number,
      totalEstimatedHours: number,
      availabilityStatus: string,
      canTakeMore: boolean
    }
  },

  // è·å–æ¨èè®¢å•
  'GET /api/order-pool/recommendations': {
    response: {
      recommendations: RecommendedOrder[]
    }
  },

  // æ›´æ–°è‡ªåŠ¨é€‰æ‹©åå¥½
  'PUT /api/technician/auto-selection-preferences': {
    body: {
      enabled: boolean,
      deviceBrands?: string[],
      repairTypes?: string[],
      difficultyRange?: [number, number],
      durationRange?: [number, number],
      avoidUrgent?: boolean,
      minConfidenceScore?: number
    }
  },

  // è·å–é€‰æ‹©å†å²
  'GET /api/technician/selection-history': {
    query: {
      page?: number,
      limit?: number,
      timeRange?: string
    },
    response: {
      selections: TechnicianSelection[],
      total: number,
      analytics: SelectionAnalytics
    }
  }
};
```

### 2. å®æ—¶é€šçŸ¥ç³»ç»Ÿ

```typescript
// WebSocketäº‹ä»¶å¤„ç†
export class OrderPoolWebSocketService {
  private ws: WebSocket;
  private technicianId: number;

  constructor(technicianId: number) {
    this.technicianId = technicianId;
    this.connect();
  }

  private connect(): void {
    this.ws = new WebSocket(`ws://localhost:3000/ws/order-pool/${this.technicianId}`);
    
    this.ws.onopen = () => {
      console.log('è®¢å•æ± WebSocketè¿æ¥å·²å»ºç«‹');
    };

    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message);
    };

    this.ws.onclose = () => {
      console.log('è®¢å•æ± WebSocketè¿æ¥å·²æ–­å¼€ï¼Œ5ç§’åé‡è¿');
      setTimeout(() => this.connect(), 5000);
    };
  }

  private handleMessage(message: WebSocketMessage): void {
    switch (message.type) {
      case 'new_order':
        this.handleNewOrder(message.data);
        break;
      case 'order_selected':
        this.handleOrderSelected(message.data);
        break;
      case 'selection_confirmed':
        this.handleSelectionConfirmed(message.data);
        break;
      case 'workload_updated':
        this.handleWorkloadUpdated(message.data);
        break;
      case 'recommendation_available':
        this.handleNewRecommendation(message.data);
        break;
    }
  }

  private handleNewOrder(orderData: OrderPoolEntry): void {
    // æ£€æŸ¥æ˜¯å¦ç¬¦åˆæŠ€æœ¯å‘˜æŠ€èƒ½
    if (this.isOrderSuitableForTechnician(orderData)) {
      // æ˜¾ç¤ºæ¡Œé¢é€šçŸ¥
      if (Notification.permission === 'granted') {
        new Notification('æ–°è®¢å•æé†’', {
          body: `æœ‰æ–°çš„ ${orderData.order.device_model} ç»´ä¿®è®¢å•å¯é€‰æ‹©`,
          icon: '/icon-192x192.png'
        });
      }

      // æ›´æ–°UI
      this.updateOrderList();
    }
  }

  private handleSelectionConfirmed(data: { selectionId: number, orderId: number }): void {
    // æ˜¾ç¤ºæˆåŠŸæé†’
    toast.success('è®¢å•é€‰æ‹©å·²ç¡®è®¤ï¼Œå¼€å§‹å¤„ç†ï¼');
    
    // æ›´æ–°å·¥ä½œè´Ÿè½½æ˜¾ç¤º
    this.updateWorkloadDisplay();
    
    // è·³è½¬åˆ°è®¢å•è¯¦æƒ…é¡µ
    router.push(`/technician/orders/${data.orderId}`);
  }

  // å‘é€å¿ƒè·³ä¿æŒè¿æ¥
  private sendHeartbeat(): void {
    setInterval(() => {
      if (this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(JSON.stringify({ type: 'heartbeat' }));
      }
    }, 30000);
  }
}
```

## ğŸ¯ å®æ–½å»ºè®®

### 1. åˆ†é˜¶æ®µå®æ–½è®¡åˆ’

```markdown
ç¬¬ä¸€é˜¶æ®µï¼šåŸºç¡€åŠŸèƒ½ (2å‘¨)
- è®¢å•æ± æ•°æ®ç»“æ„è®¾è®¡
- åŸºæœ¬çš„è®¢å•å±•ç¤ºå’Œé€‰æ‹©åŠŸèƒ½
- ç®€å•çš„æŠ€èƒ½åŒ¹é…éªŒè¯
- åŸºç¡€çš„å·¥ä½œè´Ÿè½½ç®¡ç†

ç¬¬äºŒé˜¶æ®µï¼šæ™ºèƒ½åŒ–åŠŸèƒ½ (2å‘¨)
- è®¢å•æ¨èç®—æ³•
- æ™ºèƒ½è¿‡æ»¤å’Œæ’åº
- å®æ—¶é€šçŸ¥ç³»ç»Ÿ
- é€‰æ‹©åå¥½è®¾ç½®

ç¬¬ä¸‰é˜¶æ®µï¼šé«˜çº§åŠŸèƒ½ (2å‘¨)
- è‡ªåŠ¨é€‰æ‹©åŠŸèƒ½
- ç¦»çº¿æ”¯æŒ
- è¯¦ç»†çš„åˆ†ææŠ¥è¡¨
- æ€§èƒ½ä¼˜åŒ–

ç¬¬å››é˜¶æ®µï¼šå®Œå–„å’Œä¼˜åŒ– (1å‘¨)
- ç”¨æˆ·ä½“éªŒä¼˜åŒ–
- æ€§èƒ½è°ƒä¼˜
- bugä¿®å¤
- æ–‡æ¡£å®Œå–„
```

### 2. æˆåŠŸæŒ‡æ ‡

```typescript
// ç³»ç»ŸæˆåŠŸæŒ‡æ ‡å®šä¹‰
export const SuccessMetrics = {
  // æ•ˆç‡æŒ‡æ ‡
  orderSelectionSpeed: {
    target: '< 15åˆ†é’Ÿ', // è®¢å•å‘å¸ƒåˆ°è¢«é€‰æ‹©çš„å¹³å‡æ—¶é—´
    current: '45åˆ†é’Ÿ',
    improvement: '67%'
  },
  
  // æ»¡æ„åº¦æŒ‡æ ‡
  technicianSatisfaction: {
    target: '> 8.5/10',  // æŠ€æœ¯å‘˜å¯¹æ–°ç³»ç»Ÿçš„æ»¡æ„åº¦
    current: '6.2/10',
    improvement: '37%'
  },
  
  // è´¨é‡æŒ‡æ ‡
  skillMatchAccuracy: {
    target: '> 90%',     // é€‰æ‹©è®¢å•çš„æŠ€èƒ½åŒ¹é…å‡†ç¡®ç‡
    current: '75%',
    improvement: '20%'
  },
  
  // åˆ©ç”¨ç‡æŒ‡æ ‡
  orderPoolUtilization: {
    target: '> 95%',     // è®¢å•æ± åˆ©ç”¨ç‡
    current: '82%',
    improvement: '16%'
  }
};
```

---

## ğŸ‰ æ€»ç»“

æŠ€æœ¯å‘˜è‡ªä¸»é€‰æ‹©è®¢å•ç³»ç»Ÿå°†å¸¦æ¥ä»¥ä¸‹æ ¸å¿ƒä»·å€¼ï¼š

1. **æå‡å·¥ä½œæ»¡æ„åº¦** - æŠ€æœ¯å‘˜è·å¾—æ›´å¤šè‡ªä¸»æƒ
2. **ä¼˜åŒ–æŠ€èƒ½åŒ¹é…** - å……åˆ†å‘æŒ¥ä¸ªäººä¸“ä¸šä¼˜åŠ¿  
3. **æé«˜å¤„ç†æ•ˆç‡** - ä¸»åŠ¨é€‰æ‹©å¸¦æ¥æ›´é«˜çš„å®Œæˆè´¨é‡
4. **å‡å°‘ç®¡ç†æˆæœ¬** - å‡å°‘åˆ†é…äº‰è®®å’Œé‡æ–°åˆ†é…
5. **æ•°æ®é©±åŠ¨ä¼˜åŒ–** - é€šè¿‡é€‰æ‹©åå¥½æ•°æ®ä¼˜åŒ–ä¸šåŠ¡æµç¨‹

è¿™ä¸ªç³»ç»Ÿè®¾è®¡è€ƒè™‘äº†æŠ€æœ¯å‘˜çš„å®é™…éœ€æ±‚ï¼Œæä¾›äº†çµæ´»çš„é€‰æ‹©æœºåˆ¶å’Œæ™ºèƒ½çš„æ¨èåŠŸèƒ½ï¼ŒåŒæ—¶ä¿è¯äº†ç³»ç»Ÿçš„å¯æ‰©å±•æ€§å’Œç»´æŠ¤æ€§ã€‚