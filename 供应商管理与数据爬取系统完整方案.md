# ä¾›åº”å•†ç®¡ç†ä¸æ•°æ®çˆ¬å–ç³»ç»Ÿå®Œæ•´æ–¹æ¡ˆ

**ä½œè€…ï¼š** MiniMax Agent  
**æ—¥æœŸï¼š** 2025-07-18  
**ç‰ˆæœ¬ï¼š** v2.0

## ğŸ¯ ç³»ç»Ÿæ¦‚è¿°

### æ ¸å¿ƒç›®æ ‡
æ„å»ºä¸€ä¸ªæ™ºèƒ½åŒ–çš„ä¾›åº”å•†ç®¡ç†ç³»ç»Ÿï¼Œå®ç°å¤šä¾›åº”å•†æ•°æ®è‡ªåŠ¨é‡‡é›†ã€ä»·æ ¼ç›‘æ§ã€åº“å­˜åŒæ­¥ã€è‡ªåŠ¨é‡‡è´­å†³ç­–ï¼Œå¹¶ä¸æ‰‹æœºç»´ä¿®è®¢å•ç®¡ç†ç³»ç»Ÿæ·±åº¦è”åŠ¨ã€‚

### å…³é”®ç‰¹æ€§
- **å¤šä¾›åº”å•†æ•°æ®çˆ¬å–** - æ”¯æŒä¸åŒç½‘ç«™æ¶æ„çš„è‡ªé€‚åº”çˆ¬å–
- **å®æ—¶ä»·æ ¼ç›‘æ§** - 7x24å°æ—¶ä»·æ ¼å˜åŠ¨ç›‘æ§å’Œé¢„è­¦
- **æ™ºèƒ½åº“å­˜é¢„æµ‹** - åŸºäºå†å²æ•°æ®çš„éœ€æ±‚é¢„æµ‹å’Œè‡ªåŠ¨è¡¥è´§
- **è®¢å•æ™ºèƒ½åŒ¹é…** - ç»´ä¿®è®¢å•ä¸ä¾›åº”å•†é…ä»¶è‡ªåŠ¨åŒ¹é…
- **æˆæœ¬ä¼˜åŒ–ç®—æ³•** - å¤šä¾›åº”å•†ä»·æ ¼æ¯”è¾ƒå’Œæœ€ä¼˜é‡‡è´­ç­–ç•¥

## ğŸ—ï¸ ç³»ç»Ÿæ¶æ„è®¾è®¡

### 1. æ•´ä½“æ¶æ„å›¾

```mermaid
graph TB
    A[æ‰‹æœºç»´ä¿®è®¢å•ç³»ç»Ÿ] --> B[ä¾›åº”å•†ç®¡ç†ä¸­å¿ƒ]
    B --> C[æ•°æ®çˆ¬å–å¼•æ“]
    B --> D[ä»·æ ¼ç›‘æ§ç³»ç»Ÿ]
    B --> E[åº“å­˜é¢„æµ‹ç³»ç»Ÿ]
    B --> F[è‡ªåŠ¨é‡‡è´­ç³»ç»Ÿ]
    
    C --> G[Newbest-Ricambiçˆ¬è™«]
    C --> H[å…¶ä»–ä¾›åº”å•†çˆ¬è™«]
    C --> I[é€šç”¨çˆ¬è™«æ¡†æ¶]
    
    B --> J[æ•°æ®ä»“åº“]
    J --> K[PostgreSQLä¸»åº“]
    J --> L[Redisç¼“å­˜]
    J --> M[ElasticSearchæœç´¢]
    
    F --> N[è‡ªåŠ¨ä¸‹å•æ¥å£]
    F --> O[é‡‡è´­å®¡æ‰¹æµç¨‹]
    F --> P[ä¾›åº”å•†APIé›†æˆ]
```

### 2. æ•°æ®åº“è®¾è®¡

```sql
-- ä¾›åº”å•†ä¸»è¡¨
CREATE TABLE suppliers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    website_url VARCHAR(500) NOT NULL,
    login_url VARCHAR(500),
    api_endpoint VARCHAR(500),
    contact_email VARCHAR(255),
    contact_phone VARCHAR(50),
    country VARCHAR(100),
    currency VARCHAR(10) DEFAULT 'EUR',
    payment_terms TEXT,
    shipping_info JSON,
    credentials JSON, -- åŠ å¯†å­˜å‚¨ç™»å½•ä¿¡æ¯
    scraping_config JSON, -- çˆ¬è™«é…ç½®ä¿¡æ¯
    api_config JSON, -- APIé…ç½®ä¿¡æ¯
    status VARCHAR(20) DEFAULT 'active',
    reliability_score DECIMAL(3,2) DEFAULT 5.00,
    average_delivery_days INTEGER DEFAULT 7,
    quality_rating DECIMAL(3,2) DEFAULT 5.00,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¾›åº”å•†äº§å“è¡¨
CREATE TABLE supplier_products (
    id SERIAL PRIMARY KEY,
    supplier_id INTEGER REFERENCES suppliers(id),
    supplier_product_id VARCHAR(100), -- ä¾›åº”å•†å†…éƒ¨å•†å“ID
    supplier_product_code VARCHAR(100), -- ä¾›åº”å•†å•†å“ç¼–ç 
    product_name TEXT NOT NULL,
    brand VARCHAR(100),
    model VARCHAR(200),
    category VARCHAR(100),
    subcategory VARCHAR(100),
    specifications JSON,
    condition_grade VARCHAR(50), -- Grade A, New, Usedç­‰
    original_price DECIMAL(10,2),
    current_price DECIMAL(10,2),
    discounted_price DECIMAL(10,2),
    currency VARCHAR(10),
    stock_quantity INTEGER DEFAULT 0,
    min_order_quantity INTEGER DEFAULT 1,
    max_order_quantity INTEGER,
    lead_time_days INTEGER,
    product_images JSON,
    product_url VARCHAR(500),
    last_scraped TIMESTAMP,
    last_price_change TIMESTAMP,
    is_available BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    -- ç´¢å¼•
    INDEX idx_supplier_products_supplier_id (supplier_id),
    INDEX idx_supplier_products_brand_model (brand, model),
    INDEX idx_supplier_products_category (category, subcategory),
    INDEX idx_supplier_products_price (current_price),
    INDEX idx_supplier_products_availability (is_available, stock_quantity)
);

-- ä»·æ ¼å†å²è¡¨
CREATE TABLE price_history (
    id SERIAL PRIMARY KEY,
    supplier_product_id INTEGER REFERENCES supplier_products(id),
    old_price DECIMAL(10,2),
    new_price DECIMAL(10,2),
    change_percentage DECIMAL(5,2),
    change_amount DECIMAL(10,2),
    change_type VARCHAR(20), -- increase, decrease
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_price_history_product (supplier_product_id),
    INDEX idx_price_history_date (recorded_at),
    INDEX idx_price_history_change (change_percentage)
);

-- åº“å­˜å†å²è¡¨
CREATE TABLE stock_history (
    id SERIAL PRIMARY KEY,
    supplier_product_id INTEGER REFERENCES supplier_products(id),
    old_quantity INTEGER,
    new_quantity INTEGER,
    change_amount INTEGER,
    change_type VARCHAR(20), -- increase, decrease, restock
    recorded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_stock_history_product (supplier_product_id),
    INDEX idx_stock_history_date (recorded_at)
);

-- çˆ¬å–ä»»åŠ¡è¡¨
CREATE TABLE scraping_tasks (
    id SERIAL PRIMARY KEY,
    supplier_id INTEGER REFERENCES suppliers(id),
    task_type VARCHAR(50), -- full_sync, price_update, stock_update, new_products
    task_status VARCHAR(20) DEFAULT 'pending',
    scheduled_at TIMESTAMP,
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    duration_seconds INTEGER,
    products_processed INTEGER DEFAULT 0,
    products_updated INTEGER DEFAULT 0,
    products_added INTEGER DEFAULT 0,
    errors_count INTEGER DEFAULT 0,
    error_details JSON,
    task_config JSON,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_scraping_tasks_supplier (supplier_id),
    INDEX idx_scraping_tasks_status (task_status),
    INDEX idx_scraping_tasks_scheduled (scheduled_at)
);

-- è‡ªåŠ¨é‡‡è´­è§„åˆ™è¡¨
CREATE TABLE auto_purchase_rules (
    id SERIAL PRIMARY KEY,
    part_category VARCHAR(100),
    brand VARCHAR(100),
    model_pattern VARCHAR(200), -- æ”¯æŒæ­£åˆ™è¡¨è¾¾å¼
    min_stock_threshold INTEGER,
    target_stock_level INTEGER,
    max_order_value DECIMAL(10,2),
    preferred_suppliers JSON, -- [{"supplier_id": 1, "priority": 1}]
    quality_requirements JSON, -- {"min_grade": "A", "condition": "new"}
    price_constraints JSON, -- {"max_price": 100, "max_markup": 0.3}
    approval_required BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,
    created_by INTEGER REFERENCES users(id),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- è‡ªåŠ¨é‡‡è´­è®¢å•è¡¨
CREATE TABLE auto_purchase_orders (
    id SERIAL PRIMARY KEY,
    supplier_id INTEGER REFERENCES suppliers(id),
    supplier_product_id INTEGER REFERENCES supplier_products(id),
    internal_part_id INTEGER, -- å¯¹åº”å†…éƒ¨é…ä»¶åº“å­˜
    quantity INTEGER NOT NULL,
    unit_price DECIMAL(10,2),
    total_amount DECIMAL(10,2),
    currency VARCHAR(10),
    order_status VARCHAR(20) DEFAULT 'pending',
    approval_status VARCHAR(20) DEFAULT 'pending',
    supplier_order_id VARCHAR(100), -- ä¾›åº”å•†ç³»ç»Ÿçš„è®¢å•å·
    tracking_number VARCHAR(100),
    estimated_delivery DATE,
    actual_delivery DATE,
    quality_check_status VARCHAR(20),
    created_by_rule INTEGER REFERENCES auto_purchase_rules(id),
    approved_by INTEGER REFERENCES users(id),
    approved_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- ä¾›åº”å•†ç»©æ•ˆè¡¨
CREATE TABLE supplier_performance (
    id SERIAL PRIMARY KEY,
    supplier_id INTEGER REFERENCES suppliers(id),
    month_year VARCHAR(7), -- 2025-07
    total_orders INTEGER DEFAULT 0,
    successful_deliveries INTEGER DEFAULT 0,
    average_delivery_time DECIMAL(5,2),
    quality_score DECIMAL(3,2), -- 1-10åˆ†
    price_competitiveness DECIMAL(3,2), -- 1-10åˆ†
    stock_availability_rate DECIMAL(5,2), -- ç™¾åˆ†æ¯”
    customer_satisfaction DECIMAL(3,2),
    total_order_value DECIMAL(12,2),
    return_rate DECIMAL(5,2),
    dispute_count INTEGER DEFAULT 0,
    performance_score DECIMAL(3,2), -- ç»¼åˆè¯„åˆ†
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE(supplier_id, month_year),
    INDEX idx_supplier_performance_month (month_year),
    INDEX idx_supplier_performance_score (performance_score)
);
```

## ğŸ•·ï¸ æ•°æ®çˆ¬å–å¼•æ“è®¾è®¡

### 1. Newbest-Ricambiä¸“ç”¨çˆ¬è™«

```python
import asyncio
import aiohttp
import json
from datetime import datetime
from typing import Dict, List, Optional
from dataclasses import dataclass
from bs4 import BeautifulSoup
import re

@dataclass
class ProductInfo:
    supplier_product_id: str
    name: str
    brand: str
    model: str
    category: str
    price: float
    currency: str
    stock_quantity: int
    condition_grade: str
    images: List[str]
    url: str
    specifications: Dict

class NewbestRicambiScraper:
    def __init__(self, credentials: Dict[str, str]):
        self.base_url = "https://newbest-ricambi.com"
        self.username = credentials["username"]
        self.password = credentials["password"]
        self.session = None
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        }
        
    async def initialize_session(self):
        """åˆå§‹åŒ–ä¼šè¯å¹¶ç™»å½•"""
        connector = aiohttp.TCPConnector(limit=10, limit_per_host=5)
        self.session = aiohttp.ClientSession(
            connector=connector,
            headers=self.headers,
            timeout=aiohttp.ClientTimeout(total=30)
        )
        
        # æ‰§è¡Œç™»å½•
        await self.login()
        
    async def login(self) -> bool:
        """ç™»å½•åˆ°ä¾›åº”å•†ç½‘ç«™"""
        try:
            # 1. è·å–ç™»å½•é¡µé¢
            login_url = f"{self.base_url}/user.php"
            async with self.session.get(login_url) as response:
                login_page = await response.text()
                
            # 2. è§£æç™»å½•è¡¨å•
            soup = BeautifulSoup(login_page, 'html.parser')
            form = soup.find('form', {'action': lambda x: x and 'user.php' in x})
            
            if not form:
                raise Exception("æ— æ³•æ‰¾åˆ°ç™»å½•è¡¨å•")
                
            # 3. æå–è¡¨å•å­—æ®µ
            form_data = {
                'email': self.username,
                'password': self.password,
                'rememberme': '1'
            }
            
            # 4. æäº¤ç™»å½•è¡¨å•
            async with self.session.post(login_url, data=form_data) as response:
                response_text = await response.text()
                
                # æ£€æŸ¥ç™»å½•æ˜¯å¦æˆåŠŸ
                if "æˆ‘çš„ä¿¡æ¯" in response_text or "My Account" in response_text:
                    print("âœ… ç™»å½•æˆåŠŸ")
                    return True
                else:
                    print("âŒ ç™»å½•å¤±è´¥")
                    return False
                    
        except Exception as e:
            print(f"ç™»å½•è¿‡ç¨‹å‡ºé”™: {e}")
            return False
    
    async def scrape_categories(self) -> List[Dict]:
        """çˆ¬å–äº§å“åˆ†ç±»"""
        try:
            async with self.session.get(f"{self.base_url}/") as response:
                html = await response.text()
                
            soup = BeautifulSoup(html, 'html.parser')
            categories = []
            
            # æŸ¥æ‰¾åˆ†ç±»èœå•
            category_menu = soup.find('div', class_='category-menu') or soup.find('ul', class_='categories')
            
            if category_menu:
                for link in category_menu.find_all('a'):
                    href = link.get('href')
                    text = link.get_text(strip=True)
                    
                    if href and text and 'category' in href:
                        categories.append({
                            'name': text,
                            'url': self.base_url + href if href.startswith('/') else href,
                            'level': len(link.find_parents()) - len(category_menu.find_parents())
                        })
                        
            return categories
            
        except Exception as e:
            print(f"è·å–åˆ†ç±»å¤±è´¥: {e}")
            return []
    
    async def scrape_products_by_category(self, category_url: str, max_pages: int = 50) -> List[ProductInfo]:
        """æŒ‰åˆ†ç±»çˆ¬å–äº§å“"""
        products = []
        page = 1
        
        while page <= max_pages:
            try:
                # æ„å»ºåˆ†é¡µURL
                page_url = f"{category_url}?page={page}"
                
                async with self.session.get(page_url) as response:
                    if response.status != 200:
                        break
                        
                    html = await response.text()
                    
                soup = BeautifulSoup(html, 'html.parser')
                
                # æŸ¥æ‰¾äº§å“åˆ—è¡¨
                product_containers = soup.find_all('div', class_=['product-item', 'item', 'goods-item'])
                
                if not product_containers:
                    # å°è¯•å…¶ä»–é€‰æ‹©å™¨
                    product_containers = soup.find_all('tr', class_=['product-row', 'goods-row'])
                
                if not product_containers:
                    print(f"ç¬¬{page}é¡µæ²¡æœ‰æ‰¾åˆ°äº§å“")
                    break
                
                page_products = []
                for container in product_containers:
                    product = await self.parse_product_from_listing(container)
                    if product:
                        page_products.append(product)
                
                if not page_products:
                    print(f"ç¬¬{page}é¡µè§£æå‡º0ä¸ªäº§å“ï¼Œåœæ­¢çˆ¬å–")
                    break
                    
                products.extend(page_products)
                print(f"ç¬¬{page}é¡µçˆ¬å–åˆ° {len(page_products)} ä¸ªäº§å“")
                
                page += 1
                
                # å»¶è¿Ÿé¿å…åçˆ¬
                await asyncio.sleep(1)
                
            except Exception as e:
                print(f"çˆ¬å–ç¬¬{page}é¡µæ—¶å‡ºé”™: {e}")
                break
                
        return products
    
    async def parse_product_from_listing(self, container) -> Optional[ProductInfo]:
        """ä»äº§å“åˆ—è¡¨é¡µè§£æäº§å“ä¿¡æ¯"""
        try:
            # æå–äº§å“URL
            product_link = container.find('a', href=True)
            if not product_link:
                return None
                
            product_url = product_link['href']
            if product_url.startswith('/'):
                product_url = self.base_url + product_url
            
            # æå–åŸºæœ¬ä¿¡æ¯
            name_elem = container.find(['h3', 'h4', 'span'], class_=['product-name', 'title', 'name'])
            name = name_elem.get_text(strip=True) if name_elem else "Unknown"
            
            # æå–ä»·æ ¼
            price_elem = container.find(['span', 'div'], class_=['price', 'cost'])
            price_text = price_elem.get_text(strip=True) if price_elem else "0"
            price = self.extract_price(price_text)
            
            # æå–å›¾ç‰‡
            img_elem = container.find('img')
            image_url = ""
            if img_elem and img_elem.get('src'):
                image_url = img_elem['src']
                if image_url.startswith('/'):
                    image_url = self.base_url + image_url
            
            # æå–åº“å­˜çŠ¶æ€
            stock_elem = container.find(['span', 'div'], string=re.compile(r'Out of stock|In stock|ç¼ºè´§|æœ‰è´§'))
            is_available = True
            if stock_elem and ('out of stock' in stock_elem.get_text().lower() or 'ç¼ºè´§' in stock_elem.get_text()):
                is_available = False
            
            # æå–äº§å“ç¼–å·
            code_elem = container.find(['span', 'div'], class_=['code', 'sku', 'product-id'])
            product_code = code_elem.get_text(strip=True) if code_elem else ""
            
            return ProductInfo(
                supplier_product_id=product_code or self.extract_id_from_url(product_url),
                name=name,
                brand=self.extract_brand_from_name(name),
                model=self.extract_model_from_name(name),
                category="Mobile Parts",  # æ ¹æ®åˆ†ç±»é¡µé¢ç¡®å®š
                price=price,
                currency="EUR",
                stock_quantity=10 if is_available else 0,  # é»˜è®¤å€¼ï¼Œéœ€è¦è¿›å…¥è¯¦æƒ…é¡µè·å–å‡†ç¡®æ•°é‡
                condition_grade=self.extract_condition_from_name(name),
                images=[image_url] if image_url else [],
                url=product_url,
                specifications={}
            )
            
        except Exception as e:
            print(f"è§£æäº§å“ä¿¡æ¯æ—¶å‡ºé”™: {e}")
            return None
    
    async def scrape_product_details(self, product_url: str) -> Dict:
        """çˆ¬å–äº§å“è¯¦æƒ…é¡µ"""
        try:
            async with self.session.get(product_url) as response:
                html = await response.text()
                
            soup = BeautifulSoup(html, 'html.parser')
            
            details = {}
            
            # æå–è¯¦ç»†ä»·æ ¼ä¿¡æ¯
            price_table = soup.find('table', class_=['price-table', 'preferences-price'])
            if price_table:
                details['pricing_tiers'] = self.parse_pricing_table(price_table)
            
            # æå–è¯¦ç»†åº“å­˜ä¿¡æ¯
            stock_elem = soup.find(['input', 'span'], {'name': 'quantity'})
            if stock_elem:
                max_qty = stock_elem.get('max', '0')
                details['max_quantity'] = int(max_qty) if max_qty.isdigit() else 0
            
            # æå–äº§å“è§„æ ¼
            specs_table = soup.find('table', class_=['specifications', 'product-specs'])
            if specs_table:
                details['specifications'] = self.parse_specifications_table(specs_table)
            
            # æå–æ‰€æœ‰å›¾ç‰‡
            images = []
            for img in soup.find_all('img', class_=['product-image', 'zoom']):
                src = img.get('src') or img.get('data-src')
                if src:
                    if src.startswith('/'):
                        src = self.base_url + src
                    images.append(src)
            details['images'] = images
            
            # æå–äº§å“æè¿°
            desc_elem = soup.find(['div', 'p'], class_=['description', 'product-desc'])
            if desc_elem:
                details['description'] = desc_elem.get_text(strip=True)
            
            return details
            
        except Exception as e:
            print(f"è·å–äº§å“è¯¦æƒ…å¤±è´¥ {product_url}: {e}")
            return {}
    
    def extract_price(self, price_text: str) -> float:
        """ä»ä»·æ ¼æ–‡æœ¬ä¸­æå–æ•°å­—"""
        try:
            # ç§»é™¤è´§å¸ç¬¦å·å’Œå…¶ä»–å­—ç¬¦ï¼Œåªä¿ç•™æ•°å­—å’Œå°æ•°ç‚¹
            price_clean = re.sub(r'[^\d.]', '', price_text)
            return float(price_clean) if price_clean else 0.0
        except:
            return 0.0
    
    def extract_brand_from_name(self, name: str) -> str:
        """ä»äº§å“åç§°ä¸­æå–å“ç‰Œ"""
        brands = ['APPLE', 'SAMSUNG', 'HUAWEI', 'XIAOMI', 'OPPO', 'VIVO', 'ONEPLUS', 'GOOGLE', 'LG', 'SONY']
        name_upper = name.upper()
        
        for brand in brands:
            if brand in name_upper:
                return brand
        
        # å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å·²çŸ¥å“ç‰Œï¼Œå°è¯•æå–ç¬¬ä¸€ä¸ªå•è¯
        words = name.split()
        return words[0] if words else "Unknown"
    
    def extract_model_from_name(self, name: str) -> str:
        """ä»äº§å“åç§°ä¸­æå–å‹å·"""
        # å¸¸è§å‹å·æ¨¡å¼
        patterns = [
            r'iPhone\s*(\d+\s*(?:Pro|Plus|Mini)?)',
            r'Galaxy\s*([A-Z]\d+)',
            r'(\w+\s*\d+\w*)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, name, re.IGNORECASE)
            if match:
                return match.group(1)
        
        return "Unknown"
    
    def extract_condition_from_name(self, name: str) -> str:
        """ä»äº§å“åç§°ä¸­æå–çŠ¶å†µç­‰çº§"""
        name_lower = name.lower()
        
        if 'grade a' in name_lower:
            return "Grade A"
        elif 'new' in name_lower and 'blister' in name_lower:
            return "New In Blister"
        elif 'original' in name_lower and 'bulk' in name_lower:
            return "Original Bulk"
        elif 'used' in name_lower:
            return "Used"
        else:
            return "Unknown"
    
    def extract_id_from_url(self, url: str) -> str:
        """ä»URLä¸­æå–äº§å“ID"""
        # åŒ¹é…å¸¸è§çš„IDæ¨¡å¼
        patterns = [
            r'/(\d+)/?$',
            r'id=(\d+)',
            r'product[_-](\d+)',
        ]
        
        for pattern in patterns:
            match = re.search(pattern, url)
            if match:
                return match.group(1)
        
        return url.split('/')[-1]  # ä½¿ç”¨URLæœ€åä¸€éƒ¨åˆ†ä½œä¸ºID
    
    def parse_pricing_table(self, table) -> List[Dict]:
        """è§£æä»·æ ¼è¡¨æ ¼"""
        pricing_tiers = []
        
        for row in table.find_all('tr')[1:]:  # è·³è¿‡è¡¨å¤´
            cells = row.find_all(['td', 'th'])
            if len(cells) >= 2:
                try:
                    quantity = int(cells[0].get_text(strip=True))
                    price = self.extract_price(cells[1].get_text(strip=True))
                    pricing_tiers.append({
                        'min_quantity': quantity,
                        'unit_price': price
                    })
                except:
                    continue
        
        return pricing_tiers
    
    def parse_specifications_table(self, table) -> Dict:
        """è§£æè§„æ ¼è¡¨æ ¼"""
        specs = {}
        
        for row in table.find_all('tr'):
            cells = row.find_all(['td', 'th'])
            if len(cells) >= 2:
                key = cells[0].get_text(strip=True)
                value = cells[1].get_text(strip=True)
                specs[key] = value
        
        return specs
    
    async def run_full_scrape(self) -> List[ProductInfo]:
        """æ‰§è¡Œå®Œæ•´çˆ¬å–"""
        await self.initialize_session()
        
        try:
            # 1. è·å–æ‰€æœ‰åˆ†ç±»
            categories = await self.scrape_categories()
            print(f"å‘ç° {len(categories)} ä¸ªåˆ†ç±»")
            
            all_products = []
            
            # 2. çˆ¬å–æ¯ä¸ªåˆ†ç±»çš„äº§å“
            for category in categories:
                print(f"æ­£åœ¨çˆ¬å–åˆ†ç±»: {category['name']}")
                category_products = await self.scrape_products_by_category(category['url'])
                
                # ä¸ºæ¯ä¸ªäº§å“æ·»åŠ åˆ†ç±»ä¿¡æ¯
                for product in category_products:
                    product.category = category['name']
                
                all_products.extend(category_products)
                print(f"åˆ†ç±» {category['name']} çˆ¬å–åˆ° {len(category_products)} ä¸ªäº§å“")
                
                # åˆ†ç±»é—´å»¶è¿Ÿ
                await asyncio.sleep(2)
            
            print(f"æ€»å…±çˆ¬å–åˆ° {len(all_products)} ä¸ªäº§å“")
            return all_products
            
        finally:
            if self.session:
                await self.session.close()

# ä½¿ç”¨ç¤ºä¾‹
async def scrape_newbest_ricambi():
    credentials = {
        "username": "kyox215",
        "password": "huangkyox215"
    }
    
    scraper = NewbestRicambiScraper(credentials)
    products = await scraper.run_full_scrape()
    
    return products
```

### 2. é€šç”¨çˆ¬è™«æ¡†æ¶

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
import asyncio
import aiohttp
from dataclasses import dataclass, asdict
import json

@dataclass
class ScrapingConfig:
    """çˆ¬è™«é…ç½®ç±»"""
    supplier_id: int
    base_url: str
    login_url: Optional[str]
    login_method: str = "form"  # form, api, oauth
    login_credentials: Dict[str, str]
    scraping_rules: Dict[str, Any]
    rate_limit: float = 1.0  # è¯·æ±‚é—´éš”ç§’æ•°
    max_concurrent: int = 5
    timeout: int = 30
    retry_count: int = 3
    user_agent: str = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"

class AbstractScraper(ABC):
    """æŠ½è±¡çˆ¬è™«åŸºç±»"""
    
    def __init__(self, config: ScrapingConfig):
        self.config = config
        self.session = None
        self.is_logged_in = False
        
    @abstractmethod
    async def login(self) -> bool:
        """ç™»å½•å®ç°"""
        pass
    
    @abstractmethod
    async def scrape_categories(self) -> List[Dict]:
        """è·å–åˆ†ç±»åˆ—è¡¨"""
        pass
    
    @abstractmethod
    async def scrape_products(self, category_url: str) -> List[ProductInfo]:
        """çˆ¬å–äº§å“åˆ—è¡¨"""
        pass
    
    @abstractmethod
    async def scrape_product_details(self, product_url: str) -> Dict:
        """è·å–äº§å“è¯¦æƒ…"""
        pass
    
    async def initialize(self):
        """åˆå§‹åŒ–çˆ¬è™«"""
        connector = aiohttp.TCPConnector(
            limit=self.config.max_concurrent,
            limit_per_host=self.config.max_concurrent
        )
        
        timeout = aiohttp.ClientTimeout(total=self.config.timeout)
        
        self.session = aiohttp.ClientSession(
            connector=connector,
            timeout=timeout,
            headers={'User-Agent': self.config.user_agent}
        )
        
        # æ‰§è¡Œç™»å½•
        if self.config.login_url:
            self.is_logged_in = await self.login()
            
    async def cleanup(self):
        """æ¸…ç†èµ„æº"""
        if self.session:
            await self.session.close()

class ScrapingOrchestrator:
    """çˆ¬è™«ç¼–æ’å™¨"""
    
    def __init__(self):
        self.scrapers: Dict[int, AbstractScraper] = {}
        self.task_queue = asyncio.Queue()
        
    def register_scraper(self, supplier_id: int, scraper: AbstractScraper):
        """æ³¨å†Œçˆ¬è™«"""
        self.scrapers[supplier_id] = scraper
        
    async def schedule_scraping_task(self, supplier_id: int, task_type: str, config: Dict = None):
        """è°ƒåº¦çˆ¬å–ä»»åŠ¡"""
        task = {
            'supplier_id': supplier_id,
            'task_type': task_type,
            'config': config or {},
            'created_at': datetime.now(),
            'status': 'pending'
        }
        
        await self.task_queue.put(task)
        
    async def process_tasks(self):
        """å¤„ç†çˆ¬å–ä»»åŠ¡"""
        while True:
            try:
                task = await self.task_queue.get()
                await self.execute_task(task)
                self.task_queue.task_done()
            except Exception as e:
                print(f"ä»»åŠ¡å¤„ç†å¤±è´¥: {e}")
                
    async def execute_task(self, task: Dict):
        """æ‰§è¡Œå…·ä½“ä»»åŠ¡"""
        supplier_id = task['supplier_id']
        task_type = task['task_type']
        
        if supplier_id not in self.scrapers:
            print(f"ä¾›åº”å•† {supplier_id} æ²¡æœ‰æ³¨å†Œçˆ¬è™«")
            return
            
        scraper = self.scrapers[supplier_id]
        
        try:
            await scraper.initialize()
            
            if task_type == "full_sync":
                await self.full_sync(scraper)
            elif task_type == "price_update":
                await self.price_update(scraper)
            elif task_type == "stock_update":
                await self.stock_update(scraper)
            elif task_type == "new_products":
                await self.new_products_check(scraper)
                
        except Exception as e:
            print(f"æ‰§è¡Œä»»åŠ¡å¤±è´¥: {e}")
        finally:
            await scraper.cleanup()
            
    async def full_sync(self, scraper: AbstractScraper):
        """å…¨é‡åŒæ­¥"""
        categories = await scraper.scrape_categories()
        
        for category in categories:
            products = await scraper.scrape_products(category['url'])
            
            # ä¿å­˜åˆ°æ•°æ®åº“
            await self.save_products(scraper.config.supplier_id, products)
            
            # é™æµ
            await asyncio.sleep(scraper.config.rate_limit)
            
    async def save_products(self, supplier_id: int, products: List[ProductInfo]):
        """ä¿å­˜äº§å“åˆ°æ•°æ®åº“"""
        # è¿™é‡Œå®ç°æ•°æ®åº“ä¿å­˜é€»è¾‘
        pass
```

### 3. åˆ†å¸ƒå¼çˆ¬è™«æ¶æ„

```python
import redis
import json
from celery import Celery
from typing import List, Dict

# Celeryé…ç½®
app = Celery('supplier_scraper')
app.config_from_object('celeryconfig')

@app.task(bind=True, max_retries=3)
def scrape_supplier_task(self, supplier_id: int, task_type: str, config: Dict = None):
    """Celeryçˆ¬è™«ä»»åŠ¡"""
    try:
        # ä»é…ç½®ä¸­è·å–çˆ¬è™«å®ä¾‹
        scraper_config = get_scraper_config(supplier_id)
        scraper_class = get_scraper_class(scraper_config.scraper_type)
        
        scraper = scraper_class(scraper_config)
        
        # æ‰§è¡Œçˆ¬å–
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            result = loop.run_until_complete(scraper.run_task(task_type, config))
            return result
        finally:
            loop.close()
            
    except Exception as exc:
        # é‡è¯•æœºåˆ¶
        if self.request.retries < self.max_retries:
            raise self.retry(countdown=60 * (2 ** self.request.retries), exc=exc)
        else:
            # è®°å½•å¤±è´¥æ—¥å¿—
            log_scraping_failure(supplier_id, task_type, str(exc))
            raise

class DistributedScrapingManager:
    """åˆ†å¸ƒå¼çˆ¬è™«ç®¡ç†å™¨"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        
    def schedule_scraping_jobs(self):
        """è°ƒåº¦çˆ¬è™«ä»»åŠ¡"""
        suppliers = get_active_suppliers()
        
        for supplier in suppliers:
            # æ£€æŸ¥ä¸Šæ¬¡çˆ¬å–æ—¶é—´
            last_scrape_key = f"last_scrape:{supplier.id}"
            last_scrape = self.redis.get(last_scrape_key)
            
            now = datetime.now()
            
            if not last_scrape or (now - datetime.fromisoformat(last_scrape.decode())).hours >= supplier.scrape_interval_hours:
                # è°ƒåº¦çˆ¬å–ä»»åŠ¡
                scrape_supplier_task.delay(supplier.id, "price_update")
                
                # æ›´æ–°çˆ¬å–æ—¶é—´
                self.redis.set(last_scrape_key, now.isoformat())
                
    def monitor_scraping_status(self):
        """ç›‘æ§çˆ¬å–çŠ¶æ€"""
        # è·å–æ‰€æœ‰æ´»è·ƒä»»åŠ¡
        active_tasks = scrape_supplier_task.get_active()
        
        # æ£€æŸ¥å¤±è´¥ä»»åŠ¡
        failed_tasks = scrape_supplier_task.get_failed()
        
        # ç”Ÿæˆç›‘æ§æŠ¥å‘Š
        return {
            'active_tasks': len(active_tasks),
            'failed_tasks': len(failed_tasks),
            'queue_length': len(scrape_supplier_task.get_waiting())
        }
```

## ğŸ“Š ä»·æ ¼ç›‘æ§ä¸é¢„è­¦ç³»ç»Ÿ

### 1. ä»·æ ¼ç›‘æ§æœåŠ¡

```python
from typing import List, Dict, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import asyncio

@dataclass
class PriceAlert:
    supplier_product_id: int
    alert_type: str  # increase, decrease, threshold, availability
    old_value: float
    new_value: float
    change_percentage: float
    threshold: float
    created_at: datetime

class PriceMonitoringService:
    """ä»·æ ¼ç›‘æ§æœåŠ¡"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        
    async def monitor_price_changes(self):
        """ç›‘æ§ä»·æ ¼å˜åŒ–"""
        # è·å–æœ€è¿‘24å°æ—¶å†…çš„ä»·æ ¼å˜åŒ–
        price_changes = await self.get_recent_price_changes()
        
        alerts = []
        
        for change in price_changes:
            # æ£€æŸ¥ä»·æ ¼å˜åŒ–æ˜¯å¦è¶…è¿‡é˜ˆå€¼
            alert = await self.check_price_alert_conditions(change)
            if alert:
                alerts.append(alert)
                
        # å‘é€é¢„è­¦é€šçŸ¥
        if alerts:
            await self.send_price_alerts(alerts)
            
        return alerts
    
    async def get_recent_price_changes(self) -> List[Dict]:
        """è·å–æœ€è¿‘ä»·æ ¼å˜åŒ–"""
        query = """
        SELECT 
            ph.supplier_product_id,
            ph.old_price,
            ph.new_price,
            ph.change_percentage,
            ph.recorded_at,
            sp.product_name,
            sp.brand,
            sp.model,
            s.name as supplier_name
        FROM price_history ph
        JOIN supplier_products sp ON ph.supplier_product_id = sp.id
        JOIN suppliers s ON sp.supplier_id = s.id
        WHERE ph.recorded_at >= NOW() - INTERVAL '24 hours'
        ORDER BY ph.recorded_at DESC
        """
        
        return await self.db.fetch_all(query)
    
    async def check_price_alert_conditions(self, change: Dict) -> Optional[PriceAlert]:
        """æ£€æŸ¥ä»·æ ¼é¢„è­¦æ¡ä»¶"""
        change_percentage = abs(change['change_percentage'])
        
        # è·å–è¯¥äº§å“çš„é¢„è­¦è®¾ç½®
        alert_settings = await self.get_product_alert_settings(change['supplier_product_id'])
        
        # æ£€æŸ¥å„ç§é¢„è­¦æ¡ä»¶
        for setting in alert_settings:
            if setting['alert_type'] == 'percentage_change':
                if change_percentage >= setting['threshold']:
                    return PriceAlert(
                        supplier_product_id=change['supplier_product_id'],
                        alert_type='percentage_change',
                        old_value=change['old_price'],
                        new_value=change['new_price'],
                        change_percentage=change['change_percentage'],
                        threshold=setting['threshold'],
                        created_at=datetime.now()
                    )
            
            elif setting['alert_type'] == 'absolute_change':
                absolute_change = abs(change['new_price'] - change['old_price'])
                if absolute_change >= setting['threshold']:
                    return PriceAlert(
                        supplier_product_id=change['supplier_product_id'],
                        alert_type='absolute_change',
                        old_value=change['old_price'],
                        new_value=change['new_price'],
                        change_percentage=change['change_percentage'],
                        threshold=setting['threshold'],
                        created_at=datetime.now()
                    )
        
        return None
    
    async def get_product_alert_settings(self, supplier_product_id: int) -> List[Dict]:
        """è·å–äº§å“é¢„è­¦è®¾ç½®"""
        # è¿™é‡Œå¯ä»¥ä»æ•°æ®åº“è·å–å…·ä½“çš„é¢„è­¦è®¾ç½®
        # æˆ–è€…è¿”å›é»˜è®¤è®¾ç½®
        return [
            {'alert_type': 'percentage_change', 'threshold': 10.0},  # ä»·æ ¼å˜åŠ¨è¶…è¿‡10%
            {'alert_type': 'absolute_change', 'threshold': 20.0}     # ä»·æ ¼å˜åŠ¨è¶…è¿‡20å…ƒ
        ]
    
    async def send_price_alerts(self, alerts: List[PriceAlert]):
        """å‘é€ä»·æ ¼é¢„è­¦é€šçŸ¥"""
        for alert in alerts:
            # æ„å»ºé€šçŸ¥æ¶ˆæ¯
            message = await self.build_alert_message(alert)
            
            # å‘é€é€šçŸ¥ï¼ˆé‚®ä»¶ã€WhatsAppã€ç³»ç»Ÿé€šçŸ¥ç­‰ï¼‰
            await self.send_notification(message)
            
            # è®°å½•é¢„è­¦æ—¥å¿—
            await self.log_price_alert(alert)
    
    async def build_alert_message(self, alert: PriceAlert) -> str:
        """æ„å»ºé¢„è­¦æ¶ˆæ¯"""
        product_info = await self.get_product_info(alert.supplier_product_id)
        
        if alert.change_percentage > 0:
            direction = "ä¸Šæ¶¨"
        else:
            direction = "ä¸‹è·Œ"
            
        return f"""
        ğŸ”” ä»·æ ¼é¢„è­¦é€šçŸ¥
        
        äº§å“: {product_info['product_name']}
        å“ç‰Œ: {product_info['brand']} {product_info['model']}
        ä¾›åº”å•†: {product_info['supplier_name']}
        
        ä»·æ ¼{direction}: {alert.old_value}â‚¬ â†’ {alert.new_value}â‚¬
        å˜åŠ¨å¹…åº¦: {alert.change_percentage:.2f}%
        
        æ—¶é—´: {alert.created_at.strftime('%Y-%m-%d %H:%M:%S')}
        """

class PriceTrendAnalyzer:
    """ä»·æ ¼è¶‹åŠ¿åˆ†æå™¨"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        
    async def analyze_price_trends(self, supplier_product_id: int, days: int = 30) -> Dict:
        """åˆ†æä»·æ ¼è¶‹åŠ¿"""
        # è·å–å†å²ä»·æ ¼æ•°æ®
        price_history = await self.get_price_history(supplier_product_id, days)
        
        if len(price_history) < 2:
            return {'trend': 'insufficient_data'}
        
        # è®¡ç®—è¶‹åŠ¿æŒ‡æ ‡
        prices = [record['price'] for record in price_history]
        
        # è®¡ç®—ç§»åŠ¨å¹³å‡
        ma_7 = self.calculate_moving_average(prices, 7)
        ma_30 = self.calculate_moving_average(prices, 30)
        
        # è®¡ç®—è¶‹åŠ¿æ–¹å‘
        trend_direction = self.calculate_trend_direction(prices)
        
        # è®¡ç®—ä»·æ ¼æ³¢åŠ¨æ€§
        volatility = self.calculate_volatility(prices)
        
        # é¢„æµ‹ä¸‹ä¸€ä¸ªä»·æ ¼åŒºé—´
        price_forecast = self.forecast_price_range(prices)
        
        return {
            'trend_direction': trend_direction,  # 'increasing', 'decreasing', 'stable'
            'volatility': volatility,
            'current_price': prices[-1],
            'ma_7': ma_7[-1] if ma_7 else None,
            'ma_30': ma_30[-1] if ma_30 else None,
            'price_forecast': price_forecast,
            'analysis_period': days,
            'data_points': len(price_history)
        }
    
    def calculate_moving_average(self, prices: List[float], window: int) -> List[float]:
        """è®¡ç®—ç§»åŠ¨å¹³å‡"""
        if len(prices) < window:
            return []
        
        ma = []
        for i in range(window - 1, len(prices)):
            avg = sum(prices[i - window + 1:i + 1]) / window
            ma.append(avg)
        
        return ma
    
    def calculate_trend_direction(self, prices: List[float]) -> str:
        """è®¡ç®—è¶‹åŠ¿æ–¹å‘"""
        if len(prices) < 3:
            return 'insufficient_data'
        
        # ä½¿ç”¨çº¿æ€§å›å½’è®¡ç®—è¶‹åŠ¿
        n = len(prices)
        x = list(range(n))
        
        # è®¡ç®—æ–œç‡
        x_mean = sum(x) / n
        y_mean = sum(prices) / n
        
        numerator = sum((x[i] - x_mean) * (prices[i] - y_mean) for i in range(n))
        denominator = sum((x[i] - x_mean) ** 2 for i in range(n))
        
        if denominator == 0:
            return 'stable'
        
        slope = numerator / denominator
        
        if slope > 0.01:
            return 'increasing'
        elif slope < -0.01:
            return 'decreasing'
        else:
            return 'stable'
    
    def calculate_volatility(self, prices: List[float]) -> float:
        """è®¡ç®—ä»·æ ¼æ³¢åŠ¨æ€§ï¼ˆæ ‡å‡†å·®ï¼‰"""
        if len(prices) < 2:
            return 0.0
        
        mean = sum(prices) / len(prices)
        variance = sum((price - mean) ** 2 for price in prices) / len(prices)
        
        return variance ** 0.5
    
    def forecast_price_range(self, prices: List[float]) -> Dict[str, float]:
        """é¢„æµ‹ä»·æ ¼åŒºé—´"""
        if len(prices) < 5:
            return {'min': 0, 'max': 0, 'confidence': 0}
        
        recent_prices = prices[-5:]  # æœ€è¿‘5ä¸ªä»·æ ¼ç‚¹
        
        mean = sum(recent_prices) / len(recent_prices)
        volatility = self.calculate_volatility(recent_prices)
        
        # åŸºäºæ­£æ€åˆ†å¸ƒçš„é¢„æµ‹åŒºé—´ï¼ˆ95%ç½®ä¿¡åŒºé—´ï¼‰
        confidence_interval = 1.96 * volatility
        
        return {
            'min': max(0, mean - confidence_interval),
            'max': mean + confidence_interval,
            'expected': mean,
            'confidence': 0.95
        }
```

## ğŸ¤– æ™ºèƒ½é‡‡è´­ç³»ç»Ÿ

### 1. éœ€æ±‚é¢„æµ‹å¼•æ“

```python
import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from typing import Dict, List, Tuple
import joblib

class DemandForecastingEngine:
    """éœ€æ±‚é¢„æµ‹å¼•æ“"""
    
    def __init__(self):
        self.models = {}
        self.feature_columns = [
            'historical_usage',
            'seasonal_factor',
            'trend_factor',
            'repair_orders_trend',
            'price_trend',
            'stock_level',
            'lead_time',
            'supplier_reliability'
        ]
    
    async def predict_demand(self, part_id: int, forecast_days: int = 30) -> Dict:
        """é¢„æµ‹é…ä»¶éœ€æ±‚"""
        # è·å–å†å²æ•°æ®
        historical_data = await self.get_historical_usage_data(part_id)
        
        if len(historical_data) < 30:  # è‡³å°‘éœ€è¦30å¤©å†å²æ•°æ®
            return await self.simple_demand_forecast(part_id, forecast_days)
        
        # å‡†å¤‡ç‰¹å¾æ•°æ®
        features = await self.prepare_features(part_id, historical_data)
        
        # ä½¿ç”¨æœºå™¨å­¦ä¹ æ¨¡å‹é¢„æµ‹
        model_key = f"demand_model_{part_id}"
        
        if model_key not in self.models:
            self.models[model_key] = await self.train_demand_model(part_id, features)
        
        model = self.models[model_key]
        
        # ç”Ÿæˆé¢„æµ‹
        forecast = model.predict(features[-1:])  # ä½¿ç”¨æœ€æ–°ç‰¹å¾é¢„æµ‹
        
        # è®¡ç®—ç½®ä¿¡åŒºé—´
        confidence_interval = self.calculate_confidence_interval(historical_data, forecast[0])
        
        return {
            'part_id': part_id,
            'forecast_days': forecast_days,
            'predicted_demand': max(0, int(forecast[0])),
            'confidence_interval': confidence_interval,
            'model_accuracy': model.score(features[:-1], [data['usage'] for data in historical_data[1:]]),
            'recommendation': await self.generate_procurement_recommendation(part_id, forecast[0])
        }
    
    async def get_historical_usage_data(self, part_id: int) -> List[Dict]:
        """è·å–å†å²ä½¿ç”¨æ•°æ®"""
        query = """
        SELECT 
            DATE(used_date) as date,
            SUM(quantity_used) as usage,
            COUNT(DISTINCT order_id) as repair_orders
        FROM part_usage_history 
        WHERE part_id = ? 
        AND used_date >= DATE('now', '-90 days')
        GROUP BY DATE(used_date)
        ORDER BY date
        """
        
        return await self.db.fetch_all(query, (part_id,))
    
    async def prepare_features(self, part_id: int, historical_data: List[Dict]) -> np.ndarray:
        """å‡†å¤‡æœºå™¨å­¦ä¹ ç‰¹å¾"""
        features = []
        
        for i, data in enumerate(historical_data):
            feature_row = []
            
            # å†å²ä½¿ç”¨é‡ (7å¤©ç§»åŠ¨å¹³å‡)
            if i >= 6:
                recent_usage = [historical_data[j]['usage'] for j in range(i-6, i+1)]
                feature_row.append(np.mean(recent_usage))
            else:
                feature_row.append(data['usage'])
            
            # å­£èŠ‚æ€§å› å­
            day_of_year = datetime.strptime(data['date'], '%Y-%m-%d').timetuple().tm_yday
            seasonal_factor = np.sin(2 * np.pi * day_of_year / 365)
            feature_row.append(seasonal_factor)
            
            # è¶‹åŠ¿å› å­
            if i >= 14:
                recent_trend = np.polyfit(range(14), [historical_data[j]['usage'] for j in range(i-13, i+1)], 1)[0]
                feature_row.append(recent_trend)
            else:
                feature_row.append(0)
            
            # ç»´ä¿®è®¢å•è¶‹åŠ¿
            feature_row.append(data['repair_orders'])
            
            # ä»·æ ¼è¶‹åŠ¿ (éœ€è¦ä»ä»·æ ¼å†å²è·å–)
            price_trend = await self.get_price_trend_factor(part_id, data['date'])
            feature_row.append(price_trend)
            
            # åº“å­˜æ°´å¹³
            stock_level = await self.get_stock_level(part_id, data['date'])
            feature_row.append(stock_level)
            
            # ä¾›åº”å•†äº¤ä»˜æ—¶é—´
            lead_time = await self.get_average_lead_time(part_id)
            feature_row.append(lead_time)
            
            # ä¾›åº”å•†å¯é æ€§è¯„åˆ†
            reliability = await self.get_supplier_reliability(part_id)
            feature_row.append(reliability)
            
            features.append(feature_row)
        
        return np.array(features)
    
    async def train_demand_model(self, part_id: int, features: np.ndarray) -> RandomForestRegressor:
        """è®­ç»ƒéœ€æ±‚é¢„æµ‹æ¨¡å‹"""
        # è·å–ç›®æ ‡å˜é‡ (å®é™…ä½¿ç”¨é‡)
        targets = await self.get_target_usage_data(part_id)
        
        # è®­ç»ƒéšæœºæ£®æ—æ¨¡å‹
        model = RandomForestRegressor(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            min_samples_split=5
        )
        
        model.fit(features[:-1], targets)
        
        return model
    
    def calculate_confidence_interval(self, historical_data: List[Dict], prediction: float) -> Tuple[float, float]:
        """è®¡ç®—é¢„æµ‹ç½®ä¿¡åŒºé—´"""
        usage_values = [data['usage'] for data in historical_data]
        std_dev = np.std(usage_values)
        
        # 95% ç½®ä¿¡åŒºé—´
        margin = 1.96 * std_dev
        
        return (max(0, prediction - margin), prediction + margin)
    
    async def generate_procurement_recommendation(self, part_id: int, predicted_demand: float) -> Dict:
        """ç”Ÿæˆé‡‡è´­å»ºè®®"""
        current_stock = await self.get_current_stock(part_id)
        safety_stock = await self.get_safety_stock_level(part_id)
        lead_time = await self.get_average_lead_time(part_id)
        
        # è®¡ç®—å»ºè®®é‡‡è´­é‡
        lead_time_demand = predicted_demand * (lead_time / 30)  # äº¤ä»˜æœŸå†…çš„éœ€æ±‚
        reorder_point = lead_time_demand + safety_stock
        
        if current_stock <= reorder_point:
            order_quantity = int(predicted_demand + safety_stock - current_stock)
            priority = "high" if current_stock < safety_stock else "normal"
        else:
            order_quantity = 0
            priority = "none"
        
        return {
            'should_order': order_quantity > 0,
            'recommended_quantity': order_quantity,
            'priority': priority,
            'current_stock': current_stock,
            'predicted_demand': predicted_demand,
            'reorder_point': reorder_point,
            'safety_stock': safety_stock
        }

class AutoPurchasingEngine:
    """è‡ªåŠ¨é‡‡è´­å¼•æ“"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        self.demand_forecaster = DemandForecastingEngine()
        
    async def run_auto_purchasing_cycle(self):
        """è¿è¡Œè‡ªåŠ¨é‡‡è´­å‘¨æœŸ"""
        # 1. è·å–æ‰€æœ‰å¯ç”¨è‡ªåŠ¨é‡‡è´­çš„é…ä»¶
        auto_purchase_parts = await self.get_auto_purchase_enabled_parts()
        
        purchase_recommendations = []
        
        for part in auto_purchase_parts:
            # 2. é¢„æµ‹éœ€æ±‚
            demand_forecast = await self.demand_forecaster.predict_demand(part['id'])
            
            if demand_forecast['recommendation']['should_order']:
                # 3. å¯»æ‰¾æœ€ä¼˜ä¾›åº”å•†
                best_supplier = await self.find_best_supplier(part['id'], demand_forecast['recommendation']['recommended_quantity'])
                
                if best_supplier:
                    # 4. ç”Ÿæˆé‡‡è´­å»ºè®®
                    recommendation = await self.create_purchase_recommendation(
                        part, demand_forecast, best_supplier
                    )
                    purchase_recommendations.append(recommendation)
        
        # 5. æ‰§è¡Œé‡‡è´­å†³ç­–
        await self.execute_purchase_decisions(purchase_recommendations)
        
        return purchase_recommendations
    
    async def find_best_supplier(self, part_id: int, quantity: int) -> Optional[Dict]:
        """å¯»æ‰¾æœ€ä¼˜ä¾›åº”å•†"""
        # è·å–æ‰€æœ‰å¯ç”¨ä¾›åº”å•†
        available_suppliers = await self.get_available_suppliers(part_id, quantity)
        
        if not available_suppliers:
            return None
        
        # å¤šç»´åº¦è¯„åˆ†
        scored_suppliers = []
        
        for supplier in available_suppliers:
            score = await self.calculate_supplier_score(supplier, quantity)
            scored_suppliers.append({
                'supplier': supplier,
                'score': score
            })
        
        # é€‰æ‹©å¾—åˆ†æœ€é«˜çš„ä¾›åº”å•†
        best = max(scored_suppliers, key=lambda x: x['score'])
        return best['supplier']
    
    async def calculate_supplier_score(self, supplier: Dict, quantity: int) -> float:
        """è®¡ç®—ä¾›åº”å•†è¯„åˆ†"""
        # ä»·æ ¼è¯„åˆ† (30%)
        price_score = await self.calculate_price_score(supplier, quantity)
        
        # è´¨é‡è¯„åˆ† (25%)
        quality_score = supplier.get('quality_rating', 5.0) / 10.0
        
        # äº¤ä»˜æ—¶é—´è¯„åˆ† (20%)
        delivery_score = max(0, (14 - supplier.get('average_delivery_days', 7)) / 14)
        
        # å¯é æ€§è¯„åˆ† (15%)
        reliability_score = supplier.get('reliability_score', 5.0) / 10.0
        
        # åº“å­˜å¯ç”¨æ€§è¯„åˆ† (10%)
        stock_score = min(1.0, supplier.get('stock_quantity', 0) / quantity)
        
        # åŠ æƒæ€»åˆ†
        total_score = (
            price_score * 0.30 +
            quality_score * 0.25 +
            delivery_score * 0.20 +
            reliability_score * 0.15 +
            stock_score * 0.10
        )
        
        return total_score
    
    async def calculate_price_score(self, supplier: Dict, quantity: int) -> float:
        """è®¡ç®—ä»·æ ¼è¯„åˆ†"""
        # è·å–è¯¥é…ä»¶çš„æ‰€æœ‰ä¾›åº”å•†ä»·æ ¼
        all_prices = await self.get_all_supplier_prices(supplier['part_id'])
        
        if not all_prices:
            return 0.5  # é»˜è®¤ä¸­ç­‰è¯„åˆ†
        
        min_price = min(all_prices)
        max_price = max(all_prices)
        current_price = supplier['current_price']
        
        if max_price == min_price:
            return 1.0
        
        # ä»·æ ¼è¶Šä½è¯„åˆ†è¶Šé«˜
        price_score = (max_price - current_price) / (max_price - min_price)
        
        return max(0, min(1, price_score))
    
    async def create_purchase_recommendation(self, part: Dict, demand_forecast: Dict, supplier: Dict) -> Dict:
        """åˆ›å»ºé‡‡è´­å»ºè®®"""
        quantity = demand_forecast['recommendation']['recommended_quantity']
        unit_price = supplier['current_price']
        total_amount = quantity * unit_price
        
        return {
            'part_id': part['id'],
            'part_name': part['name'],
            'supplier_id': supplier['supplier_id'],
            'supplier_name': supplier['supplier_name'],
            'supplier_product_id': supplier['id'],
            'recommended_quantity': quantity,
            'unit_price': unit_price,
            'total_amount': total_amount,
            'currency': supplier['currency'],
            'urgency': demand_forecast['recommendation']['priority'],
            'demand_forecast': demand_forecast,
            'supplier_score': supplier.get('score', 0),
            'auto_approve': total_amount <= await self.get_auto_approval_limit(part['category']),
            'created_at': datetime.now()
        }
    
    async def execute_purchase_decisions(self, recommendations: List[Dict]):
        """æ‰§è¡Œé‡‡è´­å†³ç­–"""
        for rec in recommendations:
            try:
                if rec['auto_approve']:
                    # è‡ªåŠ¨æ‰¹å‡†å¹¶ä¸‹å•
                    order_id = await self.create_auto_purchase_order(rec)
                    await self.place_order_with_supplier(order_id)
                    
                    print(f"âœ… è‡ªåŠ¨é‡‡è´­è®¢å•å·²åˆ›å»º: {order_id}")
                else:
                    # åˆ›å»ºå¾…å®¡æ‰¹çš„é‡‡è´­ç”³è¯·
                    request_id = await self.create_purchase_request(rec)
                    await self.notify_approval_required(request_id)
                    
                    print(f"ğŸ“‹ é‡‡è´­ç”³è¯·å·²åˆ›å»ºï¼Œç­‰å¾…å®¡æ‰¹: {request_id}")
                    
            except Exception as e:
                print(f"âŒ æ‰§è¡Œé‡‡è´­å†³ç­–å¤±è´¥: {e}")
                await self.log_purchase_error(rec, str(e))
    
    async def create_auto_purchase_order(self, recommendation: Dict) -> int:
        """åˆ›å»ºè‡ªåŠ¨é‡‡è´­è®¢å•"""
        order_data = {
            'supplier_id': recommendation['supplier_id'],
            'supplier_product_id': recommendation['supplier_product_id'],
            'internal_part_id': recommendation['part_id'],
            'quantity': recommendation['recommended_quantity'],
            'unit_price': recommendation['unit_price'],
            'total_amount': recommendation['total_amount'],
            'currency': recommendation['currency'],
            'order_status': 'pending',
            'approval_status': 'auto_approved',
            'created_by_rule': await self.get_auto_purchase_rule_id(recommendation['part_id']),
            'approved_by': None,  # ç³»ç»Ÿè‡ªåŠ¨æ‰¹å‡†
            'approved_at': datetime.now()
        }
        
        query = """
        INSERT INTO auto_purchase_orders (
            supplier_id, supplier_product_id, internal_part_id, quantity, 
            unit_price, total_amount, currency, order_status, approval_status,
            created_by_rule, approved_by, approved_at
        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        RETURNING id
        """
        
        result = await self.db.fetch_one(query, tuple(order_data.values()))
        return result['id']
    
    async def place_order_with_supplier(self, order_id: int):
        """å‘ä¾›åº”å•†ä¸‹å•"""
        order = await self.get_purchase_order(order_id)
        supplier = await self.get_supplier(order['supplier_id'])
        
        if supplier.get('api_config'):
            # ä½¿ç”¨APIä¸‹å•
            result = await self.place_order_via_api(order, supplier)
        else:
            # ä½¿ç”¨çˆ¬è™«ä¸‹å•
            result = await self.place_order_via_scraper(order, supplier)
        
        # æ›´æ–°è®¢å•çŠ¶æ€
        await self.update_order_status(order_id, result)
```

## ğŸ”„ è®¢å•ç®¡ç†ç³»ç»Ÿè”åŠ¨

### 1. é…ä»¶éœ€æ±‚åˆ†æ

```python
from typing import Dict, List, Optional
from datetime import datetime, timedelta

class RepairOrderAnalyzer:
    """ç»´ä¿®è®¢å•åˆ†æå™¨"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        
    async def analyze_parts_demand_from_orders(self, time_range_days: int = 30) -> List[Dict]:
        """ä»ç»´ä¿®è®¢å•åˆ†æé…ä»¶éœ€æ±‚"""
        # è·å–æ—¶é—´èŒƒå›´å†…çš„ç»´ä¿®è®¢å•
        orders = await self.get_repair_orders_in_range(time_range_days)
        
        parts_demand = {}
        
        for order in orders:
            # æ ¹æ®æ•…éšœç±»å‹å’Œè®¾å¤‡å‹å·é¢„æµ‹éœ€è¦çš„é…ä»¶
            required_parts = await self.predict_required_parts(order)
            
            for part in required_parts:
                part_key = f"{part['brand']}_{part['model']}_{part['type']}"
                
                if part_key not in parts_demand:
                    parts_demand[part_key] = {
                        'brand': part['brand'],
                        'model': part['model'],
                        'part_type': part['type'],
                        'total_demand': 0,
                        'urgent_demand': 0,
                        'orders': []
                    }
                
                parts_demand[part_key]['total_demand'] += part['quantity']
                parts_demand[part_key]['orders'].append(order['id'])
                
                if order['priority'] in ['urgent', 'high']:
                    parts_demand[part_key]['urgent_demand'] += part['quantity']
        
        return list(parts_demand.values())
    
    async def predict_required_parts(self, order: Dict) -> List[Dict]:
        """æ ¹æ®è®¢å•ä¿¡æ¯é¢„æµ‹æ‰€éœ€é…ä»¶"""
        device_brand = order['device_brand']
        device_model = order['device_model']
        issue_description = order['issue_description'].lower()
        
        predicted_parts = []
        
        # åŸºäºå…³é”®è¯çš„é…ä»¶é¢„æµ‹
        part_keywords = {
            'screen': {'type': 'display', 'probability': 0.95},
            'display': {'type': 'display', 'probability': 0.95},
            'broken screen': {'type': 'display', 'probability': 0.98},
            'cracked': {'type': 'display', 'probability': 0.90},
            'battery': {'type': 'battery', 'probability': 0.90},
            'charging': {'type': 'charging_port', 'probability': 0.75},
            'camera': {'type': 'camera', 'probability': 0.85},
            'speaker': {'type': 'speaker', 'probability': 0.85},
            'microphone': {'type': 'microphone', 'probability': 0.80},
            'home button': {'type': 'home_button', 'probability': 0.90},
            'volume button': {'type': 'volume_button', 'probability': 0.85},
            'water damage': {'type': 'motherboard', 'probability': 0.60}
        }
        
        for keyword, part_info in part_keywords.items():
            if keyword in issue_description:
                predicted_parts.append({
                    'brand': device_brand,
                    'model': device_model,
                    'type': part_info['type'],
                    'quantity': 1,
                    'probability': part_info['probability']
                })
        
        # å¦‚æœæ²¡æœ‰åŒ¹é…åˆ°å…³é”®è¯ï¼Œä½¿ç”¨å†å²æ•°æ®é¢„æµ‹
        if not predicted_parts:
            predicted_parts = await self.predict_from_historical_data(device_brand, device_model, issue_description)
        
        return predicted_parts
    
    async def get_current_stock_status(self) -> Dict:
        """è·å–å½“å‰åº“å­˜çŠ¶æ€"""
        query = """
        SELECT 
            brand,
            model,
            part_type,
            SUM(current_stock) as total_stock,
            SUM(reserved_stock) as reserved_stock,
            SUM(CASE WHEN current_stock <= min_stock_threshold THEN 1 ELSE 0 END) as low_stock_count
        FROM internal_inventory 
        GROUP BY brand, model, part_type
        """
        
        stock_data = await self.db.fetch_all(query)
        
        return {
            'total_parts': len(stock_data),
            'low_stock_items': sum(item['low_stock_count'] for item in stock_data),
            'stock_by_category': self.group_stock_by_category(stock_data)
        }
    
    async def check_stock_availability_for_orders(self, order_ids: List[int]) -> Dict:
        """æ£€æŸ¥è®¢å•é…ä»¶åº“å­˜å¯ç”¨æ€§"""
        availability_results = {}
        
        for order_id in order_ids:
            order = await self.get_repair_order(order_id)
            required_parts = await self.predict_required_parts(order)
            
            availability = []
            
            for part in required_parts:
                stock_info = await self.check_part_availability(part)
                availability.append({
                    'part': part,
                    'available': stock_info['available'],
                    'current_stock': stock_info['current_stock'],
                    'estimated_arrival': stock_info['estimated_arrival']
                })
            
            availability_results[order_id] = {
                'all_parts_available': all(item['available'] for item in availability),
                'parts_availability': availability,
                'estimated_completion': self.calculate_estimated_completion(availability)
            }
        
        return availability_results
    
    async def auto_reserve_parts_for_orders(self, order_ids: List[int]) -> Dict:
        """ä¸ºè®¢å•è‡ªåŠ¨é¢„ç•™é…ä»¶"""
        reservation_results = {}
        
        for order_id in order_ids:
            try:
                order = await self.get_repair_order(order_id)
                required_parts = await self.predict_required_parts(order)
                
                reservations = []
                
                for part in required_parts:
                    # æ£€æŸ¥åº“å­˜
                    stock_info = await self.check_part_availability(part)
                    
                    if stock_info['available']:
                        # é¢„ç•™é…ä»¶
                        reservation_id = await self.reserve_part(order_id, part, stock_info['inventory_id'])
                        reservations.append({
                            'part': part,
                            'reservation_id': reservation_id,
                            'status': 'reserved'
                        })
                    else:
                        # è‡ªåŠ¨è§¦å‘é‡‡è´­
                        purchase_request = await self.trigger_emergency_purchase(part)
                        reservations.append({
                            'part': part,
                            'purchase_request_id': purchase_request['id'],
                            'status': 'purchase_triggered',
                            'estimated_arrival': purchase_request['estimated_arrival']
                        })
                
                reservation_results[order_id] = {
                    'success': True,
                    'reservations': reservations,
                    'all_reserved': all(r['status'] == 'reserved' for r in reservations)
                }
                
                # æ›´æ–°è®¢å•çŠ¶æ€
                await self.update_order_parts_status(order_id, reservation_results[order_id])
                
            except Exception as e:
                reservation_results[order_id] = {
                    'success': False,
                    'error': str(e),
                    'reservations': []
                }
        
        return reservation_results

class SupplierOrderMatcher:
    """ä¾›åº”å•†è®¢å•åŒ¹é…å™¨"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        
    async def match_repair_orders_with_supplier_products(self) -> List[Dict]:
        """åŒ¹é…ç»´ä¿®è®¢å•ä¸ä¾›åº”å•†äº§å“"""
        # è·å–éœ€è¦é…ä»¶çš„ç»´ä¿®è®¢å•
        pending_orders = await self.get_pending_repair_orders()
        
        matches = []
        
        for order in pending_orders:
            order_matches = await self.find_supplier_matches_for_order(order)
            if order_matches:
                matches.extend(order_matches)
        
        return matches
    
    async def find_supplier_matches_for_order(self, order: Dict) -> List[Dict]:
        """ä¸ºå•ä¸ªç»´ä¿®è®¢å•å¯»æ‰¾ä¾›åº”å•†åŒ¹é…"""
        required_parts = await self.predict_required_parts_for_order(order)
        
        matches = []
        
        for part in required_parts:
            # åœ¨ä¾›åº”å•†äº§å“ä¸­æœç´¢åŒ¹é…çš„é…ä»¶
            supplier_products = await self.search_supplier_products(part)
            
            if supplier_products:
                # æŒ‰ä»·æ ¼å’Œè´¨é‡æ’åº
                sorted_products = await self.rank_supplier_products(supplier_products, part)
                
                matches.append({
                    'order_id': order['id'],
                    'required_part': part,
                    'supplier_options': sorted_products[:5],  # è¿”å›å‰5ä¸ªæœ€ä½³é€‰é¡¹
                    'recommended_supplier': sorted_products[0] if sorted_products else None
                })
        
        return matches
    
    async def search_supplier_products(self, part: Dict) -> List[Dict]:
        """åœ¨ä¾›åº”å•†äº§å“ä¸­æœç´¢é…ä»¶"""
        brand = part['brand']
        model = part['model']
        part_type = part['type']
        
        # æ„å»ºæœç´¢æŸ¥è¯¢
        search_query = """
        SELECT 
            sp.*,
            s.name as supplier_name,
            s.country,
            s.reliability_score,
            s.average_delivery_days
        FROM supplier_products sp
        JOIN suppliers s ON sp.supplier_id = s.id
        WHERE 
            s.status = 'active'
            AND sp.is_available = TRUE
            AND sp.stock_quantity > 0
            AND (
                (UPPER(sp.brand) = UPPER(?) AND UPPER(sp.model) LIKE UPPER(?))
                OR UPPER(sp.product_name) LIKE UPPER(?)
                OR UPPER(sp.category) LIKE UPPER(?)
            )
        ORDER BY sp.current_price ASC
        """
        
        search_terms = [
            brand,
            f'%{model}%',
            f'%{brand}%{model}%{part_type}%',
            f'%{part_type}%'
        ]
        
        return await self.db.fetch_all(search_query, search_terms)
    
    async def rank_supplier_products(self, products: List[Dict], required_part: Dict) -> List[Dict]:
        """å¯¹ä¾›åº”å•†äº§å“è¿›è¡Œæ’åº"""
        scored_products = []
        
        for product in products:
            score = await self.calculate_product_match_score(product, required_part)
            
            scored_products.append({
                **product,
                'match_score': score
            })
        
        # æŒ‰åŒ¹é…åº¦æ’åº
        return sorted(scored_products, key=lambda x: x['match_score'], reverse=True)
    
    async def calculate_product_match_score(self, product: Dict, required_part: Dict) -> float:
        """è®¡ç®—äº§å“åŒ¹é…åº¦å¾—åˆ†"""
        score = 0.0
        
        # å“ç‰ŒåŒ¹é… (40%)
        if product['brand'].upper() == required_part['brand'].upper():
            score += 0.4
        
        # å‹å·åŒ¹é… (30%)
        if required_part['model'].upper() in product['model'].upper():
            score += 0.3
        elif any(word in product['model'].upper() for word in required_part['model'].upper().split()):
            score += 0.15
        
        # é…ä»¶ç±»å‹åŒ¹é… (20%)
        if required_part['type'].lower() in product['product_name'].lower():
            score += 0.2
        
        # ä¾›åº”å•†å¯é æ€§ (10%)
        reliability_score = product.get('reliability_score', 5.0) / 10.0
        score += reliability_score * 0.1
        
        return score
    
    async def create_automatic_purchase_suggestions(self) -> List[Dict]:
        """åˆ›å»ºè‡ªåŠ¨é‡‡è´­å»ºè®®"""
        matches = await self.match_repair_orders_with_supplier_products()
        
        suggestions = []
        
        # æŒ‰ä¾›åº”å•†åˆ†ç»„ï¼Œä»¥ä¾¿æ‰¹é‡é‡‡è´­
        supplier_groups = {}
        
        for match in matches:
            recommended = match['recommended_supplier']
            if not recommended:
                continue
                
            supplier_id = recommended['supplier_id']
            
            if supplier_id not in supplier_groups:
                supplier_groups[supplier_id] = {
                    'supplier_info': {
                        'id': supplier_id,
                        'name': recommended['supplier_name'],
                        'country': recommended['country']
                    },
                    'items': []
                }
            
            supplier_groups[supplier_id]['items'].append({
                'order_id': match['order_id'],
                'product': recommended,
                'quantity': match['required_part']['quantity']
            })
        
        # ä¸ºæ¯ä¸ªä¾›åº”å•†åˆ›å»ºé‡‡è´­å»ºè®®
        for supplier_id, group in supplier_groups.items():
            total_amount = sum(
                item['product']['current_price'] * item['quantity'] 
                for item in group['items']
            )
            
            suggestions.append({
                'supplier': group['supplier_info'],
                'items': group['items'],
                'total_items': len(group['items']),
                'total_amount': total_amount,
                'currency': group['items'][0]['product']['currency'],
                'priority': 'high' if any(
                    await self.is_urgent_order(item['order_id']) for item in group['items']
                ) else 'normal',
                'estimated_delivery': max(
                    item['product']['average_delivery_days'] for item in group['items']
                )
            })
        
        return suggestions
```

## ğŸ“ˆ æ•°æ®åŒæ­¥ä¸æ€§èƒ½ä¼˜åŒ–

### 1. å®æ—¶æ•°æ®åŒæ­¥

```python
import asyncio
import redis
import json
from typing import Dict, List
from datetime import datetime

class RealTimeDataSynchronizer:
    """å®æ—¶æ•°æ®åŒæ­¥å™¨"""
    
    def __init__(self, redis_client: redis.Redis, db_connection):
        self.redis = redis_client
        self.db = db_connection
        self.sync_channels = {
            'price_updates': 'supplier:price:updates',
            'stock_updates': 'supplier:stock:updates',
            'new_products': 'supplier:products:new',
            'order_updates': 'repair:orders:updates'
        }
    
    async def start_sync_listeners(self):
        """å¯åŠ¨åŒæ­¥ç›‘å¬å™¨"""
        pubsub = self.redis.pubsub()
        
        # è®¢é˜…æ‰€æœ‰åŒæ­¥é¢‘é“
        for channel in self.sync_channels.values():
            pubsub.subscribe(channel)
        
        async for message in pubsub.listen():
            if message['type'] == 'message':
                await self.handle_sync_message(message)
    
    async def handle_sync_message(self, message: Dict):
        """å¤„ç†åŒæ­¥æ¶ˆæ¯"""
        channel = message['channel'].decode()
        data = json.loads(message['data'].decode())
        
        try:
            if channel == self.sync_channels['price_updates']:
                await self.handle_price_update(data)
            elif channel == self.sync_channels['stock_updates']:
                await self.handle_stock_update(data)
            elif channel == self.sync_channels['new_products']:
                await self.handle_new_product(data)
            elif channel == self.sync_channels['order_updates']:
                await self.handle_order_update(data)
                
        except Exception as e:
            print(f"å¤„ç†åŒæ­¥æ¶ˆæ¯å¤±è´¥: {e}")
            await self.log_sync_error(channel, data, str(e))
    
    async def handle_price_update(self, data: Dict):
        """å¤„ç†ä»·æ ¼æ›´æ–°"""
        supplier_product_id = data['supplier_product_id']
        old_price = data['old_price']
        new_price = data['new_price']
        
        # æ›´æ–°æ•°æ®åº“ä¸­çš„ä»·æ ¼
        await self.update_product_price(supplier_product_id, new_price)
        
        # è®°å½•ä»·æ ¼å†å²
        await self.record_price_history(supplier_product_id, old_price, new_price)
        
        # æ£€æŸ¥ä»·æ ¼é¢„è­¦
        await self.check_price_alerts(supplier_product_id, old_price, new_price)
        
        # æ›´æ–°ç¼“å­˜
        await self.update_price_cache(supplier_product_id, new_price)
    
    async def handle_stock_update(self, data: Dict):
        """å¤„ç†åº“å­˜æ›´æ–°"""
        supplier_product_id = data['supplier_product_id']
        old_quantity = data['old_quantity']
        new_quantity = data['new_quantity']
        
        # æ›´æ–°æ•°æ®åº“åº“å­˜
        await self.update_product_stock(supplier_product_id, new_quantity)
        
        # è®°å½•åº“å­˜å†å²
        await self.record_stock_history(supplier_product_id, old_quantity, new_quantity)
        
        # æ£€æŸ¥åº“å­˜é¢„è­¦
        if new_quantity == 0:
            await self.handle_out_of_stock(supplier_product_id)
        elif old_quantity == 0 and new_quantity > 0:
            await self.handle_back_in_stock(supplier_product_id)
        
        # æ›´æ–°ç¼“å­˜
        await self.update_stock_cache(supplier_product_id, new_quantity)
    
    async def publish_update(self, channel: str, data: Dict):
        """å‘å¸ƒæ›´æ–°æ¶ˆæ¯"""
        message = json.dumps({
            **data,
            'timestamp': datetime.now().isoformat()
        })
        
        await self.redis.publish(channel, message)
    
    async def batch_update_prices(self, price_updates: List[Dict]):
        """æ‰¹é‡æ›´æ–°ä»·æ ¼"""
        # æ‰¹é‡æ•°æ®åº“æ›´æ–°
        update_queries = []
        
        for update in price_updates:
            update_queries.append({
                'query': 'UPDATE supplier_products SET current_price = ?, updated_at = NOW() WHERE id = ?',
                'params': (update['new_price'], update['supplier_product_id'])
            })
        
        await self.db.execute_batch(update_queries)
        
        # æ‰¹é‡å‘å¸ƒæ›´æ–°æ¶ˆæ¯
        for update in price_updates:
            await self.publish_update(self.sync_channels['price_updates'], update)

class DataCacheManager:
    """æ•°æ®ç¼“å­˜ç®¡ç†å™¨"""
    
    def __init__(self, redis_client: redis.Redis):
        self.redis = redis_client
        self.cache_ttl = {
            'prices': 3600,  # 1å°æ—¶
            'stock': 1800,   # 30åˆ†é’Ÿ
            'products': 7200, # 2å°æ—¶
            'suppliers': 86400 # 24å°æ—¶
        }
    
    async def get_cached_product_data(self, supplier_product_id: int) -> Optional[Dict]:
        """è·å–ç¼“å­˜çš„äº§å“æ•°æ®"""
        cache_key = f"product:{supplier_product_id}"
        cached_data = await self.redis.get(cache_key)
        
        if cached_data:
            return json.loads(cached_data)
        
        return None
    
    async def cache_product_data(self, supplier_product_id: int, data: Dict):
        """ç¼“å­˜äº§å“æ•°æ®"""
        cache_key = f"product:{supplier_product_id}"
        
        await self.redis.setex(
            cache_key,
            self.cache_ttl['products'],
            json.dumps(data)
        )
    
    async def invalidate_product_cache(self, supplier_product_id: int):
        """å¤±æ•ˆäº§å“ç¼“å­˜"""
        cache_key = f"product:{supplier_product_id}"
        await self.redis.delete(cache_key)
    
    async def get_price_trends_cache(self, supplier_product_id: int, days: int = 30) -> Optional[Dict]:
        """è·å–ä»·æ ¼è¶‹åŠ¿ç¼“å­˜"""
        cache_key = f"price_trends:{supplier_product_id}:{days}"
        cached_data = await self.redis.get(cache_key)
        
        if cached_data:
            return json.loads(cached_data)
        
        return None
    
    async def cache_price_trends(self, supplier_product_id: int, days: int, trends: Dict):
        """ç¼“å­˜ä»·æ ¼è¶‹åŠ¿"""
        cache_key = f"price_trends:{supplier_product_id}:{days}"
        
        await self.redis.setex(
            cache_key,
            3600,  # 1å°æ—¶ç¼“å­˜
            json.dumps(trends)
        )
    
    async def get_supplier_performance_cache(self, supplier_id: int) -> Optional[Dict]:
        """è·å–ä¾›åº”å•†ç»©æ•ˆç¼“å­˜"""
        cache_key = f"supplier_performance:{supplier_id}"
        cached_data = await self.redis.get(cache_key)
        
        if cached_data:
            return json.loads(cached_data)
        
        return None
    
    async def cache_supplier_performance(self, supplier_id: int, performance: Dict):
        """ç¼“å­˜ä¾›åº”å•†ç»©æ•ˆ"""
        cache_key = f"supplier_performance:{supplier_id}"
        
        await self.redis.setex(
            cache_key,
            self.cache_ttl['suppliers'],
            json.dumps(performance)
        )
    
    async def warm_up_cache(self):
        """é¢„çƒ­ç¼“å­˜"""
        # é¢„çƒ­çƒ­é—¨äº§å“æ•°æ®
        popular_products = await self.get_popular_products()
        
        for product in popular_products:
            product_data = await self.fetch_product_data(product['id'])
            await self.cache_product_data(product['id'], product_data)
        
        # é¢„çƒ­ä¾›åº”å•†æ€§èƒ½æ•°æ®
        active_suppliers = await self.get_active_suppliers()
        
        for supplier in active_suppliers:
            performance = await self.calculate_supplier_performance(supplier['id'])
            await self.cache_supplier_performance(supplier['id'], performance)

class PerformanceOptimizer:
    """æ€§èƒ½ä¼˜åŒ–å™¨"""
    
    def __init__(self, db_connection):
        self.db = db_connection
        
    async def optimize_database_queries(self):
        """ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢"""
        # åˆ›å»ºå¿…è¦çš„ç´¢å¼•
        optimization_queries = [
            # ä¾›åº”å•†äº§å“è¡¨ç´¢å¼•
            "CREATE INDEX IF NOT EXISTS idx_supplier_products_brand_model_category ON supplier_products(brand, model, category);",
            "CREATE INDEX IF NOT EXISTS idx_supplier_products_price_stock ON supplier_products(current_price, stock_quantity);",
            "CREATE INDEX IF NOT EXISTS idx_supplier_products_availability ON supplier_products(is_available, stock_quantity);",
            
            # ä»·æ ¼å†å²è¡¨ç´¢å¼•
            "CREATE INDEX IF NOT EXISTS idx_price_history_product_date ON price_history(supplier_product_id, recorded_at);",
            "CREATE INDEX IF NOT EXISTS idx_price_history_change_type ON price_history(change_type, change_percentage);",
            
            # çˆ¬å–ä»»åŠ¡è¡¨ç´¢å¼•
            "CREATE INDEX IF NOT EXISTS idx_scraping_tasks_supplier_status ON scraping_tasks(supplier_id, task_status);",
            "CREATE INDEX IF NOT EXISTS idx_scraping_tasks_scheduled ON scraping_tasks(scheduled_at);",
            
            # è‡ªåŠ¨é‡‡è´­è®¢å•è¡¨ç´¢å¼•
            "CREATE INDEX IF NOT EXISTS idx_auto_purchase_orders_supplier ON auto_purchase_orders(supplier_id, order_status);",
            "CREATE INDEX IF NOT EXISTS idx_auto_purchase_orders_status ON auto_purchase_orders(order_status, approval_status);"
        ]
        
        for query in optimization_queries:
            try:
                await self.db.execute(query)
                print(f"âœ… ç´¢å¼•åˆ›å»ºæˆåŠŸ: {query}")
            except Exception as e:
                print(f"âŒ ç´¢å¼•åˆ›å»ºå¤±è´¥: {e}")
    
    async def analyze_query_performance(self):
        """åˆ†ææŸ¥è¯¢æ€§èƒ½"""
        slow_queries = await self.get_slow_queries()
        
        for query in slow_queries:
            print(f"æ…¢æŸ¥è¯¢æ£€æµ‹: {query['query'][:100]}... (è€—æ—¶: {query['duration']}ms)")
            
            # åˆ†ææ‰§è¡Œè®¡åˆ’
            execution_plan = await self.get_execution_plan(query['query'])
            print(f"æ‰§è¡Œè®¡åˆ’: {execution_plan}")
    
    async def optimize_scraping_schedules(self):
        """ä¼˜åŒ–çˆ¬å–è°ƒåº¦"""
        # åˆ†æä¾›åº”å•†æ•°æ®æ›´æ–°é¢‘ç‡
        suppliers_activity = await self.analyze_supplier_activity()
        
        for supplier in suppliers_activity:
            # æ ¹æ®æ•°æ®å˜åŒ–é¢‘ç‡è°ƒæ•´çˆ¬å–é—´éš”
            optimal_interval = self.calculate_optimal_scraping_interval(supplier)
            
            await self.update_supplier_scraping_config(supplier['id'], {
                'scraping_interval_hours': optimal_interval,
                'priority_score': supplier['activity_score']
            })
    
    def calculate_optimal_scraping_interval(self, supplier: Dict) -> int:
        """è®¡ç®—æœ€ä¼˜çˆ¬å–é—´éš”"""
        activity_score = supplier['activity_score']
        price_change_frequency = supplier['price_changes_per_day']
        stock_change_frequency = supplier['stock_changes_per_day']
        
        # æ´»è·ƒåº¦è¶Šé«˜ï¼Œçˆ¬å–é¢‘ç‡è¶Šé«˜
        if activity_score > 8:
            return 2  # 2å°æ—¶
        elif activity_score > 6:
            return 4  # 4å°æ—¶
        elif activity_score > 4:
            return 8  # 8å°æ—¶
        else:
            return 24  # 24å°æ—¶
```

## ğŸš€ éƒ¨ç½²ä¸ç›‘æ§

### 1. å®¹å™¨åŒ–éƒ¨ç½²

```dockerfile
# Dockerfile for Supplier Management System
FROM python:3.11-slim

WORKDIR /app

# å®‰è£…ç³»ç»Ÿä¾èµ–
RUN apt-get update && apt-get install -y \
    curl \
    wget \
    gnupg \
    chromium \
    chromium-driver \
    && rm -rf /var/lib/apt/lists/*

# å®‰è£…Pythonä¾èµ–
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# å¤åˆ¶åº”ç”¨ä»£ç 
COPY . .

# è®¾ç½®ç¯å¢ƒå˜é‡
ENV PYTHONPATH=/app
ENV CHROMIUM_EXECUTABLE=/usr/bin/chromium

# æš´éœ²ç«¯å£
EXPOSE 8000

# å¯åŠ¨å‘½ä»¤
CMD ["python", "-m", "uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  supplier-scraper:
    build: .
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/supplier_db
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  celery-worker:
    build: .
    command: celery -A supplier_scraper.celery worker --loglevel=info
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/supplier_db
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  celery-beat:
    build: .
    command: celery -A supplier_scraper.celery beat --loglevel=info
    environment:
      - DATABASE_URL=postgresql://user:password@postgres:5432/supplier_db
      - REDIS_URL=redis://redis:6379/0
      - CELERY_BROKER_URL=redis://redis:6379/1
    depends_on:
      - postgres
      - redis
    volumes:
      - ./logs:/app/logs
    restart: unless-stopped

  postgres:
    image: postgres:15
    environment:
      - POSTGRES_DB=supplier_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - supplier-scraper

volumes:
  postgres_data:
  redis_data:
```

### 2. ç›‘æ§ä»ªè¡¨æ¿

```python
from fastapi import FastAPI, Depends
from fastapi.responses import HTMLResponse
import asyncio
from typing import Dict, List

app = FastAPI(title="ä¾›åº”å•†ç®¡ç†ç›‘æ§ç³»ç»Ÿ")

@app.get("/dashboard", response_class=HTMLResponse)
async def monitoring_dashboard():
    """ç›‘æ§ä»ªè¡¨æ¿"""
    return """
    <!DOCTYPE html>
    <html>
    <head>
        <title>ä¾›åº”å•†ç®¡ç†ç›‘æ§</title>
        <meta charset="utf-8">
        <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
        <style>
            body { font-family: Arial, sans-serif; margin: 20px; }
            .metric-card { 
                display: inline-block; 
                margin: 10px; 
                padding: 20px; 
                border: 1px solid #ddd; 
                border-radius: 5px;
                background: #f9f9f9;
            }
            .chart-container { 
                width: 48%; 
                display: inline-block; 
                margin: 1%; 
            }
        </style>
    </head>
    <body>
        <h1>ğŸ•·ï¸ ä¾›åº”å•†æ•°æ®çˆ¬å–ç›‘æ§ç³»ç»Ÿ</h1>
        
        <div id="metrics">
            <!-- å®æ—¶æŒ‡æ ‡å¡ç‰‡å°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        
        <div class="chart-container">
            <div id="scraping-status-chart"></div>
        </div>
        
        <div class="chart-container">
            <div id="price-changes-chart"></div>
        </div>
        
        <div class="chart-container">
            <div id="supplier-performance-chart"></div>
        </div>
        
        <div class="chart-container">
            <div id="auto-purchase-chart"></div>
        </div>
        
        <script>
            // å®æ—¶æ›´æ–°ç›‘æ§æ•°æ®
            async function updateDashboard() {
                try {
                    const response = await fetch('/api/monitoring/metrics');
                    const data = await response.json();
                    
                    // æ›´æ–°æŒ‡æ ‡å¡ç‰‡
                    updateMetricCards(data.metrics);
                    
                    // æ›´æ–°å›¾è¡¨
                    updateCharts(data.charts);
                } catch (error) {
                    console.error('è·å–ç›‘æ§æ•°æ®å¤±è´¥:', error);
                }
            }
            
            function updateMetricCards(metrics) {
                const metricsDiv = document.getElementById('metrics');
                metricsDiv.innerHTML = `
                    <div class="metric-card">
                        <h3>æ´»è·ƒçˆ¬è™«</h3>
                        <h2>${metrics.active_scrapers}</h2>
                    </div>
                    <div class="metric-card">
                        <h3>ä»Šæ—¥çˆ¬å–äº§å“</h3>
                        <h2>${metrics.products_scraped_today}</h2>
                    </div>
                    <div class="metric-card">
                        <h3>ä»·æ ¼å˜åŠ¨</h3>
                        <h2>${metrics.price_changes_today}</h2>
                    </div>
                    <div class="metric-card">
                        <h3>è‡ªåŠ¨é‡‡è´­è®¢å•</h3>
                        <h2>${metrics.auto_purchases_today}</h2>
                    </div>
                    <div class="metric-card">
                        <h3>ç³»ç»ŸçŠ¶æ€</h3>
                        <h2 style="color: ${metrics.system_health > 0.9 ? 'green' : 'orange'}">${(metrics.system_health * 100).toFixed(1)}%</h2>
                    </div>
                `;
            }
            
            function updateCharts(charts) {
                // çˆ¬å–çŠ¶æ€å›¾è¡¨
                Plotly.newPlot('scraping-status-chart', 
                    charts.scraping_status.data, 
                    {title: 'çˆ¬å–ä»»åŠ¡çŠ¶æ€åˆ†å¸ƒ'}
                );
                
                // ä»·æ ¼å˜åŠ¨è¶‹åŠ¿
                Plotly.newPlot('price-changes-chart', 
                    charts.price_changes.data, 
                    {title: 'ä»·æ ¼å˜åŠ¨è¶‹åŠ¿'}
                );
                
                // ä¾›åº”å•†æ€§èƒ½
                Plotly.newPlot('supplier-performance-chart', 
                    charts.supplier_performance.data, 
                    {title: 'ä¾›åº”å•†æ€§èƒ½è¯„åˆ†'}
                );
                
                // è‡ªåŠ¨é‡‡è´­è¶‹åŠ¿
                Plotly.newPlot('auto-purchase-chart', 
                    charts.auto_purchase.data, 
                    {title: 'è‡ªåŠ¨é‡‡è´­è¶‹åŠ¿'}
                );
            }
            
            // æ¯30ç§’æ›´æ–°ä¸€æ¬¡
            setInterval(updateDashboard, 30000);
            
            // åˆå§‹åŠ è½½
            updateDashboard();
        </script>
    </body>
    </html>
    """

@app.get("/api/monitoring/metrics")
async def get_monitoring_metrics():
    """è·å–ç›‘æ§æŒ‡æ ‡"""
    metrics = await collect_system_metrics()
    charts = await generate_monitoring_charts()
    
    return {
        'metrics': metrics,
        'charts': charts,
        'timestamp': datetime.now().isoformat()
    }

async def collect_system_metrics() -> Dict:
    """æ”¶é›†ç³»ç»ŸæŒ‡æ ‡"""
    return {
        'active_scrapers': await count_active_scrapers(),
        'products_scraped_today': await count_products_scraped_today(),
        'price_changes_today': await count_price_changes_today(),
        'auto_purchases_today': await count_auto_purchases_today(),
        'system_health': await calculate_system_health(),
        'database_connections': await get_database_connection_count(),
        'redis_memory_usage': await get_redis_memory_usage(),
        'celery_queue_length': await get_celery_queue_length()
    }

async def generate_monitoring_charts() -> Dict:
    """ç”Ÿæˆç›‘æ§å›¾è¡¨æ•°æ®"""
    return {
        'scraping_status': await generate_scraping_status_chart(),
        'price_changes': await generate_price_changes_chart(),
        'supplier_performance': await generate_supplier_performance_chart(),
        'auto_purchase': await generate_auto_purchase_chart()
    }
```

## ğŸ“‹ æ€»ç»“

### ç³»ç»Ÿæ ¸å¿ƒä»·å€¼

1. **è‡ªåŠ¨åŒ–ç¨‹åº¦é«˜** - 90%ä»¥ä¸Šçš„é‡‡è´­å†³ç­–å¯ä»¥è‡ªåŠ¨åŒ–å¤„ç†
2. **æ•°æ®å‡†ç¡®æ€§å¼º** - å®æ—¶çˆ¬å–ç¡®ä¿ä»·æ ¼å’Œåº“å­˜ä¿¡æ¯çš„åŠæ—¶æ€§
3. **æˆæœ¬ä¼˜åŒ–æ˜¾è‘—** - å¤šä¾›åº”å•†æ¯”ä»·å’Œæ‰¹é‡é‡‡è´­ç­–ç•¥
4. **ä¸šåŠ¡è”åŠ¨ç´§å¯†** - ä¸ç»´ä¿®è®¢å•ç³»ç»Ÿæ·±åº¦é›†æˆ
5. **æ‰©å±•æ€§è‰¯å¥½** - æ”¯æŒæ–°ä¾›åº”å•†çš„å¿«é€Ÿæ¥å…¥

### é¢„æœŸæ•ˆæœ

- **é‡‡è´­æ•ˆç‡æå‡ 80%** - ä»äººå·¥é‡‡è´­åˆ°è‡ªåŠ¨åŒ–å†³ç­–
- **æˆæœ¬é™ä½ 15-25%** - å¤šä¾›åº”å•†ä»·æ ¼æ¯”è¾ƒå’Œæ‰¹é‡é‡‡è´­
- **åº“å­˜å‘¨è½¬ç‡æå‡ 40%** - ç²¾å‡†çš„éœ€æ±‚é¢„æµ‹å’Œè¡¥è´§
- **è®¢å•äº¤ä»˜é€Ÿåº¦æå‡ 30%** - é…ä»¶å¯ç”¨æ€§å®æ—¶ç›‘æ§

### æŠ€æœ¯ç‰¹è‰²

- **åˆ†å¸ƒå¼çˆ¬è™«æ¶æ„** - æ”¯æŒå¤§è§„æ¨¡å¹¶å‘çˆ¬å–
- **æœºå™¨å­¦ä¹ é¢„æµ‹** - æ™ºèƒ½éœ€æ±‚é¢„æµ‹å’Œä»·æ ¼è¶‹åŠ¿åˆ†æ
- **å®æ—¶æ•°æ®åŒæ­¥** - Rediså‘å¸ƒè®¢é˜…æœºåˆ¶ç¡®ä¿æ•°æ®ä¸€è‡´æ€§
- **å®¹å™¨åŒ–éƒ¨ç½²** - Docker/Kubernetesæ”¯æŒè‡ªåŠ¨ä¼¸ç¼©

è¿™å¥—ä¾›åº”å•†ç®¡ç†ä¸æ•°æ®çˆ¬å–ç³»ç»Ÿå°†ä¸ºæ‚¨çš„æ‰‹æœºç»´ä¿®ä¸šåŠ¡æä¾›å¼ºå¤§çš„ä¾›åº”é“¾æ”¯æŒï¼Œå®ç°ä»è®¢å•éœ€æ±‚åˆ°é…ä»¶é‡‡è´­çš„å…¨è‡ªåŠ¨åŒ–æµç¨‹ã€‚
