# 手机维修系统 - 业务流程与数据流设计

**作者：** MiniMax Agent  
**日期：** 2025-07-17

## 核心业务流程设计

### 1. 完整订单生命周期流程

#### 1.1 订单创建阶段
```mermaid
graph TD
    A[客户咨询] --> B{咨询方式}
    B -->|在线咨询| C[在线报价系统]
    B -->|电话咨询| D[客服接待]
    B -->|到店咨询| E[前台接待]
    
    C --> F[设备信息录入]
    D --> F
    E --> F
    
    F --> G[故障描述记录]
    G --> H[初步报价评估]
    H --> I{客户确认}
    
    I -->|确认| J[创建正式订单]
    I -->|需要调整| K[报价调整]
    I -->|暂不维修| L[咨询记录存档]
    
    K --> H
    J --> M[订单号生成]
    M --> N[客户通知]
    N --> O[订单进入待分配状态]
```

#### 1.2 订单分配与执行阶段
```mermaid
graph TD
    A[订单待分配] --> B[管理员查看订单]
    B --> C{技术员分配策略}
    
    C -->|自动分配| D[系统智能分配]
    C -->|手动分配| E[管理员指定分配]
    
    D --> F[技术员接收通知]
    E --> F
    
    F --> G{技术员响应}
    G -->|接受| H[订单状态更新为已接单]
    G -->|拒绝| I[重新分配]
    G -->|超时| J[自动重新分配]
    
    I --> C
    J --> C
    
    H --> K[技术员查看订单详情]
    K --> L[联系客户确认]
    L --> M[开始故障诊断]
```

#### 1.3 维修执行阶段
```mermaid
graph TD
    A[开始诊断] --> B[设备外观检查]
    B --> C[功能测试]
    C --> D[故障确认]
    D --> E[维修方案制定]
    E --> F{需要配件}
    
    F -->|需要| G[查询库存]
    F -->|不需要| L[开始维修]
    
    G --> H{库存充足}
    H -->|充足| I[配件领用]
    H -->|不足| J[紧急采购/调货]
    
    J --> K[等待配件到货]
    K --> I
    I --> L
    
    L --> M[维修过程记录]
    M --> N[维修完成]
    N --> O[功能测试]
    O --> P{测试通过}
    
    P -->|通过| Q[质量检查]
    P -->|不通过| R[继续维修]
    
    R --> M
    Q --> S[客户通知]
    S --> T[客户验收]
```

#### 1.4 订单完成阶段
```mermaid
graph TD
    A[客户验收] --> B{验收结果}
    B -->|满意| C[确认完成]
    B -->|不满意| D[问题记录]
    
    D --> E{问题性质}
    E -->|技术问题| F[重新维修]
    E -->|服务问题| G[服务补偿]
    
    F --> H[维修执行阶段]
    G --> I[补偿方案执行]
    I --> C
    
    C --> J[费用结算]
    J --> K[发票开具]
    K --> L[设备交付]
    L --> M[订单状态更新为已完成]
    
    M --> N[客户满意度调查]
    N --> O[售后跟踪]
    O --> P[客户关系维护]
```

### 2. 库存管理业务流程

#### 2.1 库存监控与预警流程
```mermaid
graph TD
    A[系统自动监控] --> B{库存水平检查}
    B -->|正常| C[继续监控]
    B -->|低于安全库存| D[生成预警通知]
    B -->|缺货| E[生成紧急补货通知]
    
    D --> F[通知采购人员]
    E --> F
    
    F --> G[评估补货需求]
    G --> H[制定采购计划]
    H --> I[供应商询价]
    I --> J[采购决策]
    
    J --> K[创建采购订单]
    K --> L[供应商确认]
    L --> M[订单跟踪]
    M --> N[到货验收]
    N --> O[入库处理]
    O --> P[库存更新]
    
    P --> C
```

#### 2.2 配件申请与分发流程
```mermaid
graph TD
    A[技术员发起配件申请] --> B[申请信息填写]
    B --> C[订单关联确认]
    C --> D[提交申请]
    
    D --> E[管理员审核]
    E --> F{审核结果}
    
    F -->|通过| G[库存可用性检查]
    F -->|拒绝| H[拒绝原因通知]
    F -->|需要补充信息| I[申请修改要求]
    
    I --> B
    H --> J[申请结束]
    
    G --> K{库存状态}
    K -->|充足| L[配件分配]
    K -->|不足| M[缺货处理]
    
    M --> N{处理方式}
    N -->|等待补货| O[加入等待队列]
    N -->|紧急采购| P[启动紧急采购]
    N -->|替代方案| Q[寻找替代配件]
    
    L --> R[生成出库单]
    R --> S[技术员领取]
    S --> T[配件使用记录]
    T --> U[库存数量更新]
```

### 3. 客户服务业务流程

#### 3.1 客户咨询处理流程
```mermaid
graph TD
    A[客户发起咨询] --> B{咨询渠道}
    B -->|在线客服| C[在线接待]
    B -->|电话咨询| D[电话接听]
    B -->|微信咨询| E[微信回复]
    B -->|到店咨询| F[前台接待]
    
    C --> G[咨询内容分类]
    D --> G
    E --> G
    F --> G
    
    G --> H{问题类型}
    H -->|常见问题| I[标准答案回复]
    H -->|技术问题| J[技术人员协助]
    H -->|投诉问题| K[投诉处理流程]
    H -->|维修咨询| L[维修咨询流程]
    
    I --> M[客户满意度确认]
    J --> M
    K --> N[投诉处理记录]
    L --> O[报价或订单创建]
    
    M --> P[咨询记录保存]
    N --> P
    O --> P
    
    P --> Q[客户关系更新]
```

#### 3.2 客户投诉处理流程
```mermaid
graph TD
    A[客户投诉] --> B[投诉信息记录]
    B --> C[投诉分级]
    C --> D{投诉级别}
    
    D -->|一般投诉| E[客服处理]
    D -->|严重投诉| F[主管介入]
    D -->|重大投诉| G[管理层处理]
    
    E --> H[问题调查]
    F --> H
    G --> H
    
    H --> I[原因分析]
    I --> J[解决方案制定]
    J --> K[客户沟通]
    K --> L{客户满意}
    
    L -->|满意| M[投诉结案]
    L -->|不满意| N[方案调整]
    
    N --> J
    M --> O[经验总结]
    O --> P[流程改进]
```

## 数据流设计

### 1. 实时数据同步架构

#### 1.1 数据同步流向图
```mermaid
graph TD
    A[前端操作] --> B[API Gateway]
    B --> C[业务逻辑层]
    C --> D[数据库写入]
    D --> E[事件触发]
    
    E --> F[消息队列]
    F --> G[数据同步服务]
    
    G --> H[缓存更新]
    G --> I[搜索索引更新]
    G --> J[报表数据更新]
    G --> K[通知服务]
    
    K --> L[短信通知]
    K --> M[邮件通知]
    K --> N[系统内消息]
    K --> O[微信推送]
    
    H --> P[前端缓存刷新]
    I --> Q[搜索结果更新]
    J --> R[报表数据刷新]
```

#### 1.2 订单状态数据流
```mermaid
sequenceDiagram
    participant C as 客户端
    participant T as 技术员端
    participant A as 管理员端
    participant S as 后端服务
    participant D as 数据库
    participant N as 通知服务
    
    T->>S: 更新订单状态
    S->>D: 写入状态变更
    D->>S: 确认写入成功
    S->>N: 触发状态变更事件
    
    N->>C: 推送状态更新通知
    N->>A: 推送管理通知
    N->>T: 确认操作成功
    
    S->>S: 更新缓存数据
    S->>S: 更新搜索索引
    S->>S: 更新统计数据
```

#### 1.3 库存数据流
```mermaid
sequenceDiagram
    participant T as 技术员
    participant I as 库存系统
    participant P as 采购系统
    participant S as 供应商
    participant N as 通知系统
    
    T->>I: 申请配件
    I->>I: 检查库存
    I->>T: 库存不足通知
    I->>P: 自动生成采购需求
    P->>S: 发送采购订单
    S->>P: 确认订单
    P->>I: 更新预计到货时间
    I->>N: 发送到货通知
    N->>T: 通知预计到货时间
    
    S->>P: 发货通知
    P->>I: 更新在途库存
    I->>I: 到货验收
    I->>T: 配件可用通知
```

### 2. 数据一致性保证机制

#### 2.1 事务处理机制
```typescript
// 订单创建事务示例
async function createOrder(orderData) {
  const transaction = await db.beginTransaction();
  
  try {
    // 1. 创建订单记录
    const order = await db.orders.create(orderData, { transaction });
    
    // 2. 创建客户记录（如果不存在）
    await db.customers.upsert(orderData.customer, { transaction });
    
    // 3. 创建订单状态历史
    await db.orderStatusHistory.create({
      orderId: order.id,
      status: 'PENDING',
      notes: '订单创建',
      createdBy: orderData.createdBy
    }, { transaction });
    
    // 4. 更新客户统计信息
    await db.customers.increment('orderCount', {
      where: { id: orderData.customerId },
      transaction
    });
    
    // 5. 提交事务
    await transaction.commit();
    
    // 6. 触发后续事件
    await eventBus.emit('order.created', order);
    
    return order;
  } catch (error) {
    // 回滚事务
    await transaction.rollback();
    throw error;
  }
}
```

#### 2.2 数据校验机制
```typescript
// 多层数据校验
class OrderValidator {
  // 前端校验
  static validateClientSide(data) {
    return z.object({
      customerName: z.string().min(2),
      phone: z.string().regex(/^1[3-9]\d{9}$/),
      deviceModel: z.string().min(1),
      issueDescription: z.string().min(10)
    }).parse(data);
  }
  
  // API层校验
  static validateApiLayer(data) {
    // 业务规则校验
    if (data.estimatedCost < 0) {
      throw new Error('费用不能为负数');
    }
    
    // 重复订单检查
    const duplicateOrder = await this.checkDuplicateOrder(data);
    if (duplicateOrder) {
      throw new Error('存在重复订单');
    }
  }
  
  // 数据库层校验
  static validateDatabaseLayer(data) {
    // 外键约束校验
    // 数据格式校验
    // 业务规则校验
  }
}
```

### 3. 缓存策略设计

#### 3.1 多级缓存架构
```mermaid
graph TD
    A[用户请求] --> B[浏览器缓存]
    B --> C{缓存命中?}
    C -->|是| D[返回缓存数据]
    C -->|否| E[CDN缓存]
    
    E --> F{CDN命中?}
    F -->|是| G[返回CDN数据]
    F -->|否| H[应用服务器]
    
    H --> I[应用内存缓存]
    I --> J{内存命中?}
    J -->|是| K[返回内存数据]
    J -->|否| L[Redis缓存]
    
    L --> M{Redis命中?}
    M -->|是| N[返回Redis数据]
    M -->|否| O[数据库查询]
    
    O --> P[数据库返回]
    P --> Q[更新各级缓存]
    Q --> R[返回最终数据]
```

#### 3.2 缓存更新策略
```typescript
// 智能缓存更新
class CacheManager {
  // 订单相关缓存更新
  async updateOrderCache(orderId, updateData) {
    // 1. 删除相关缓存
    await this.invalidateCache([
      `order:${orderId}`,
      `orders:technician:${updateData.technicianId}`,
      `orders:customer:${updateData.customerId}`,
      'orders:statistics',
      'dashboard:overview'
    ]);
    
    // 2. 预热关键缓存
    await this.preloadCache([
      `order:${orderId}`,
      'orders:active',
      'dashboard:overview'
    ]);
  }
  
  // 库存相关缓存更新
  async updateInventoryCache(partId, quantity) {
    await this.invalidateCache([
      `inventory:${partId}`,
      'inventory:low-stock',
      'dashboard:inventory'
    ]);
    
    // 如果库存低于警戒线，立即更新相关缓存
    if (quantity < LOW_STOCK_THRESHOLD) {
      await this.preloadCache(['inventory:low-stock']);
    }
  }
}
```

## API接口设计

### 1. RESTful API 设计规范

#### 1.1 订单管理API
```typescript
// 订单相关API端点
interface OrderAPI {
  // 获取订单列表
  'GET /api/orders': {
    query: {
      status?: OrderStatus;
      technicianId?: string;
      customerId?: string;
      dateFrom?: string;
      dateTo?: string;
      page?: number;
      limit?: number;
    };
    response: PaginatedResponse<OrderWithRelations>;
  };
  
  // 创建新订单
  'POST /api/orders': {
    body: CreateOrderRequest;
    response: OrderResponse;
  };
  
  // 获取订单详情
  'GET /api/orders/:id': {
    params: { id: string };
    response: OrderDetailResponse;
  };
  
  // 更新订单状态
  'PATCH /api/orders/:id/status': {
    params: { id: string };
    body: { status: OrderStatus; notes?: string };
    response: OrderResponse;
  };
  
  // 分配技术员
  'POST /api/orders/:id/assign': {
    params: { id: string };
    body: { technicianId: string };
    response: OrderResponse;
  };
}
```

#### 1.2 库存管理API
```typescript
interface InventoryAPI {
  // 获取库存列表
  'GET /api/inventory': {
    query: {
      category?: string;
      lowStock?: boolean;
      search?: string;
      page?: number;
      limit?: number;
    };
    response: PaginatedResponse<InventoryItem>;
  };
  
  // 配件申请
  'POST /api/inventory/requests': {
    body: {
      orderId: string;
      items: Array<{
        partId: string;
        quantity: number;
        urgency: 'normal' | 'urgent';
      }>;
      notes?: string;
    };
    response: InventoryRequestResponse;
  };
  
  // 配件出库
  'POST /api/inventory/:id/checkout': {
    params: { id: string };
    body: {
      quantity: number;
      orderId: string;
      technicianId: string;
    };
    response: InventoryResponse;
  };
}
```

### 2. WebSocket 实时通信

#### 2.1 实时消息推送
```typescript
// WebSocket 事件定义
interface WebSocketEvents {
  // 订单状态更新
  'order.status.updated': {
    orderId: string;
    newStatus: OrderStatus;
    oldStatus: OrderStatus;
    technicianId?: string;
    customerId: string;
    timestamp: Date;
  };
  
  // 新订单分配
  'order.assigned': {
    orderId: string;
    technicianId: string;
    orderInfo: OrderBasicInfo;
    assignedBy: string;
    timestamp: Date;
  };
  
  // 库存预警
  'inventory.low.stock': {
    partId: string;
    partName: string;
    currentStock: number;
    minStock: number;
    urgentOrders: string[];
  };
  
  // 客户消息
  'customer.message': {
    customerId: string;
    orderId?: string;
    message: string;
    channel: 'phone' | 'online' | 'wechat';
    timestamp: Date;
  };
}
```

#### 2.2 实时协作功能
```typescript
// 订单协作示例
class OrderCollaboration {
  // 技术员更新订单时的实时协作
  async updateOrderWithCollaboration(orderId: string, updateData: any, technicianId: string) {
    // 1. 检查是否有其他人正在编辑
    const lockInfo = await this.checkOrderLock(orderId);
    if (lockInfo && lockInfo.userId !== technicianId) {
      throw new Error(`订单正在被${lockInfo.userName}编辑中`);
    }
    
    // 2. 加锁编辑
    await this.lockOrder(orderId, technicianId);
    
    try {
      // 3. 更新数据
      const updatedOrder = await this.updateOrder(orderId, updateData);
      
      // 4. 实时通知相关人员
      await this.notifyStakeholders(orderId, {
        type: 'order.updated',
        updatedBy: technicianId,
        changes: updateData
      });
      
      return updatedOrder;
    } finally {
      // 5. 释放锁
      await this.unlockOrder(orderId);
    }
  }
}
```

### 3. 数据同步API

#### 3.1 增量同步机制
```typescript
// 增量数据同步
interface SyncAPI {
  // 获取变更数据
  'GET /api/sync/changes': {
    query: {
      lastSyncTime: string;
      modules: string[]; // ['orders', 'inventory', 'customers']
    };
    response: {
      changes: {
        orders: ChangeRecord[];
        inventory: ChangeRecord[];
        customers: ChangeRecord[];
      };
      nextSyncTime: string;
    };
  };
  
  // 批量数据同步
  'POST /api/sync/batch': {
    body: {
      changes: ChangeRecord[];
    };
    response: {
      success: boolean;
      conflicts: ConflictRecord[];
      syncTime: string;
    };
  };
}

interface ChangeRecord {
  id: string;
  table: string;
  operation: 'create' | 'update' | 'delete';
  data: any;
  timestamp: Date;
  version: number;
}
```

## 系统集成方案

### 1. 第三方系统集成

#### 1.1 支付系统集成
```typescript
// 支付系统集成
class PaymentIntegration {
  // 统一支付接口
  async processPayment(orderId: string, paymentData: PaymentRequest) {
    const order = await this.getOrder(orderId);
    
    // 根据支付方式选择支付通道
    const paymentGateway = this.selectPaymentGateway(paymentData.method);
    
    // 创建支付订单
    const paymentOrder = await paymentGateway.createPayment({
      amount: order.finalCost,
      orderId: order.orderNumber,
      description: `维修费用-${order.deviceModel}`,
      notifyUrl: `${process.env.API_BASE_URL}/api/payments/notify`,
      returnUrl: `${process.env.FRONTEND_URL}/orders/${orderId}/payment-result`
    });
    
    // 记录支付记录
    await this.createPaymentRecord({
      orderId,
      paymentOrderId: paymentOrder.id,
      amount: order.finalCost,
      method: paymentData.method,
      status: 'pending'
    });
    
    return paymentOrder;
  }
}
```

#### 1.2 短信邮件服务集成
```typescript
// 消息服务集成
class NotificationService {
  // 多渠道消息发送
  async sendNotification(notification: NotificationRequest) {
    const { recipients, content, channels, priority } = notification;
    
    const results = await Promise.allSettled(
      channels.map(async (channel) => {
        switch (channel) {
          case 'sms':
            return await this.smsService.send(recipients, content.sms);
          case 'email':
            return await this.emailService.send(recipients, content.email);
          case 'wechat':
            return await this.wechatService.send(recipients, content.wechat);
          case 'push':
            return await this.pushService.send(recipients, content.push);
        }
      })
    );
    
    // 记录发送结果
    await this.logNotificationResults(notification.id, results);
    
    return results;
  }
}
```

### 2. 数据迁移方案

#### 2.1 系统迁移策略
```typescript
// 数据迁移管理
class DataMigration {
  // 分阶段迁移
  async migrateInPhases() {
    const phases = [
      'customers',      // 第一阶段：客户数据
      'inventory',      // 第二阶段：库存数据
      'orders',         // 第三阶段：订单数据
      'financial'       // 第四阶段：财务数据
    ];
    
    for (const phase of phases) {
      console.log(`开始迁移 ${phase} 数据...`);
      
      try {
        await this.executePhase(phase);
        await this.validatePhase(phase);
        console.log(`${phase} 数据迁移完成`);
      } catch (error) {
        console.error(`${phase} 数据迁移失败:`, error);
        await this.rollbackPhase(phase);
        throw error;
      }
    }
  }
  
  // 数据校验
  async validateMigration() {
    const validations = [
      this.validateDataIntegrity(),
      this.validateBusinessRules(),
      this.validatePerformance()
    ];
    
    const results = await Promise.all(validations);
    return results.every(result => result.success);
  }
}
```

这个详细的业务流程与数据流设计文档确保了系统各个功能模块之间的完整互通。每个业务流程都经过精心设计，形成了完整的闭环，同时保证了数据的一致性和系统的高可用性。